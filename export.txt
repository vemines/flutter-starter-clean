Path: lib\injection_container.dart
Code:
import 'package:dio/dio.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:get_it/get_it.dart';
import 'package:internet_connection_checker_plus/internet_connection_checker_plus.dart';
import 'package:shared_preferences/shared_preferences.dart';

import 'app/flavor.dart';
import 'app/logs.dart';
import 'core/network/network_info.dart';
import 'features/auth/data/datasources/auth_local_data_source.dart';
import 'features/auth/data/datasources/auth_remote_data_source.dart';
import 'features/auth/data/repositories/auth_repository_impl.dart';
import 'features/auth/domain/repositories/auth_repository.dart';
import 'features/auth/domain/usecases/get_logged_in_user_usecase.dart';
import 'features/auth/domain/usecases/login_usecase.dart';
import 'features/auth/domain/usecases/logout_usecase.dart';
import 'features/auth/domain/usecases/register_usecase.dart';
import 'features/auth/domain/usecases/update_password_usecase.dart';
import 'features/auth/presentation/blocs/auth_bloc.dart';
import 'features/comment/data/datasources/comment_remote_data_source.dart';
import 'features/comment/data/repositories/comment_repository_impl.dart';
import 'features/comment/domain/repositories/comment_repository.dart';
import 'features/comment/domain/usecases/add_comment_usecase.dart';
import 'features/comment/domain/usecases/delete_comment_usecase.dart';
import 'features/comment/domain/usecases/get_comments_by_post_id_usecase.dart';
import 'features/comment/domain/usecases/update_comment_usecase.dart';
import 'features/comment/presentation/blocs/comment_bloc.dart';
import 'features/post/data/datasources/post_remote_data_source.dart';
import 'features/post/data/repositories/post_repository_impl.dart';
import 'features/post/domain/repositories/post_repository.dart';
import 'features/post/domain/usecases/create_post_usecase.dart';
import 'features/post/domain/usecases/delete_post_usecase.dart';
import 'features/post/domain/usecases/get_all_posts_usecase.dart';
import 'features/post/domain/usecases/get_bookmarked_posts_usecase.dart';
import 'features/post/domain/usecases/get_post_by_id_usecase.dart';
import 'features/post/domain/usecases/get_posts_by_user_id_usecase.dart';
import 'features/post/domain/usecases/search_posts_usecase.dart';
import 'features/post/domain/usecases/update_post_usecase.dart';
import 'features/post/presentation/blocs/post_bloc.dart';
import 'features/user/data/datasources/user_remote_data_source.dart';
import 'features/user/data/repositories/user_repository_impl.dart';
import 'features/user/domain/repositories/user_repository.dart';
import 'features/user/domain/usecases/bookmark_post_usecase.dart';
import 'features/user/domain/usecases/get_all_users_usecase.dart';
import 'features/user/domain/usecases/get_user_by_id_usecase.dart';
import 'features/user/domain/usecases/get_user_detail_usecase.dart';
import 'features/user/domain/usecases/update_friend_list_usecase.dart';
import 'features/user/domain/usecases/update_user_usecase.dart';
import 'features/user/presentation/blocs/user_bloc.dart';
import 'features/user/presentation/blocs/user_detail_bloc.dart';

final sl = GetIt.instance;

Future<void> init() async {
  // Features
  // Bloc
  sl.registerLazySingleton(
    () => AuthBloc(
      loginUseCase: sl(),
      registerUseCase: sl(),
      getLoggedInUserUseCase: sl(),
      logoutUseCase: sl(),
      updatePasswordUseCase: sl(),
      logService: sl(),
    ),
  );
  sl.registerFactory(
    () => PostBloc(
      getAllPosts: sl(),
      getPostById: sl(),
      createPost: sl(),
      updatePost: sl(),
      deletePost: sl(),
      searchPosts: sl(),
      getBookmarkedPosts: sl(),
      getPostsByUserIdUseCase: sl(),
      logService: sl(),
    ),
  );
  sl.registerFactory(
    () => UserBloc(
      getAllUsersUseCase: sl(),
      getUserByIdUseCase: sl(),
      updateUserUseCase: sl(),
      updateFriendListUseCase: sl(),
      bookmarkPostUseCase: sl(),
      logService: sl(),
    ),
  );
  sl.registerLazySingleton(() => UserDetailBloc(getUserDetailUseCase: sl(), logService: sl()));
  sl.registerFactory(
    () => CommentBloc(
      addComment: sl(),
      deleteComment: sl(),
      getCommentsByPostId: sl(),
      updateComment: sl(),
      logService: sl(),
    ),
  );

  // Use cases
  // -- Auth
  sl.registerLazySingleton(() => LoginUseCase(sl()));
  sl.registerLazySingleton(() => RegisterUseCase(sl()));
  sl.registerLazySingleton(() => GetLoggedInUserUseCase(sl()));
  sl.registerLazySingleton(() => LogoutUseCase(sl()));
  sl.registerLazySingleton(() => UpdatePasswordUseCase(sl()));

  // -- Post
  sl.registerLazySingleton(() => GetAllPostsUseCase(sl()));
  sl.registerLazySingleton(() => GetPostByIdUseCase(sl()));
  sl.registerLazySingleton(() => CreatePostUseCase(sl()));
  sl.registerLazySingleton(() => UpdatePostUseCase(sl()));
  sl.registerLazySingleton(() => DeletePostUseCase(sl()));
  sl.registerLazySingleton(() => SearchPostsUseCase(sl()));
  sl.registerLazySingleton(() => GetBookmarkedPostsUseCase(sl()));
  sl.registerLazySingleton(() => GetPostsByUserIdUseCase(sl()));

  // -- User
  sl.registerLazySingleton(() => BookmarkPostUseCase(sl()));
  sl.registerLazySingleton(() => GetAllUsersUseCase(sl()));
  sl.registerLazySingleton(() => GetUserDetailUseCase(sl()));
  sl.registerLazySingleton(() => GetUserByIdUseCase(sl()));
  sl.registerLazySingleton(() => UpdateUserUseCase(sl()));
  sl.registerLazySingleton(() => UpdateFriendListUseCase(sl()));

  // -- Comment
  sl.registerLazySingleton(() => GetCommentsByPostIdUseCase(sl()));
  sl.registerLazySingleton(() => AddCommentUseCase(sl()));
  sl.registerLazySingleton(() => UpdateCommentUseCase(sl()));
  sl.registerLazySingleton(() => DeleteCommentUseCase(sl()));

  // Repository
  sl.registerLazySingleton<AuthRepository>(
    () => AuthRepositoryImpl(remoteDataSource: sl(), localDataSource: sl(), networkInfo: sl()),
  );
  sl.registerLazySingleton<CommentRepository>(
    () => CommentRepositoryImpl(remoteDataSource: sl(), networkInfo: sl()),
  );
  sl.registerLazySingleton<PostRepository>(
    () => PostRepositoryImpl(remoteDataSource: sl(), networkInfo: sl()),
  );
  sl.registerLazySingleton<UserRepository>(
    () => UserRepositoryImpl(remoteDataSource: sl(), networkInfo: sl()),
  );

  // Data sources
  sl.registerLazySingleton<AuthRemoteDataSource>(() => AuthRemoteDataSourceImpl(dio: sl()));
  sl.registerLazySingleton<AuthLocalDataSource>(() => AuthLocalDataSourceImpl(secureStorage: sl()));
  sl.registerLazySingleton<PostRemoteDataSource>(() => PostRemoteDataSourceImpl(dio: sl()));
  sl.registerLazySingleton<UserRemoteDataSource>(() => UserRemoteDataSourceImpl(dio: sl()));
  sl.registerLazySingleton<CommentRemoteDataSource>(() => CommentRemoteDataSourceImpl(dio: sl()));
  //! Core
  sl.registerLazySingleton<NetworkInfo>(() => NetworkInfoImpl(sl()));

  //! External
  final sharedPreferences = await SharedPreferences.getInstance();
  sl.registerLazySingleton(() => sharedPreferences);
  sl.registerLazySingleton(() => InternetConnection());
  sl.registerLazySingleton(() => const FlutterSecureStorage());

  final logService = await LogService.instance();
  sl.registerLazySingleton<LogService>(() => logService);

  sl.registerLazySingleton<Dio>(() {
    final dio = Dio();
    final flavor = FlavorService.instance.config;

    dio.options.baseUrl = flavor.baseUrl;
    dio.options.connectTimeout = Duration(seconds: flavor.requestTimeout);
    dio.options.receiveTimeout = Duration(seconds: flavor.requestTimeout);

    dio.interceptors.add(
      InterceptorsWrapper(
        onRequest: (options, handler) {
          // sl<LogService>().d('Request: ${options.method} ${options.uri}');
          return handler.next(options);
        },
        onResponse: (response, handler) {
          // sl<LogService>().d('Response: ${response.statusCode} ${response.data}');
          // sl<LogService>().d('Response: ${response.statusCode}');
          return handler.next(response);
        },
        onError: (DioException e, handler) {
          sl<LogService>().e('DioError: ${e.message}', error: e, stackTrace: e.stackTrace);
          return handler.next(e);
        },
      ),
    );

    return dio;
  });
}


Path: lib\main_development.dart
Code:
import 'package:flutter/material.dart';

import 'app/app.dart';
import 'app/flavor.dart';
import 'injection_container.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  FlavorService.initialize(Flavor.dev);

  await init();

  runApp(const App());
}


Path: lib\main_production.dart
Code:
import 'package:flutter/material.dart';

import 'app/app.dart';
import 'app/flavor.dart';
import 'injection_container.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  FlavorService.initialize(Flavor.prod);

  await init();

  runApp(const App());
}


Path: lib\main_staging.dart
Code:
import 'package:flutter/material.dart';

import 'app/app.dart';
import 'app/flavor.dart';
import 'injection_container.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  FlavorService.initialize(Flavor.staging);

  await init();

  runApp(const App());
}


Path: lib\app\app.dart
Code:
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_starter_clean/features/auth/presentation/blocs/auth_bloc.dart';

import '../configs/configs.dart';
import '../injection_container.dart';
import 'cubits/cubits.dart';
import 'locale.dart';
import 'routes.dart';

class App extends StatelessWidget {
  const App({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiBlocProvider(
      providers: [
        BlocProvider(create: (context) => ThemeCubit()),
        BlocProvider(create: (context) => LogCubit()..initialize()),
        BlocProvider(create: (context) => LocaleCubit()),
        // Provide feature-specific BLoCs using GetIt
        BlocProvider(create: (context) => sl<AuthBloc>()..add(GetLoggedInUserEvent())),
      ],
      child: const _App(),
    );
  }
}

class _App extends StatelessWidget {
  const _App();

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<ThemeCubit, ThemeData>(
      builder: (_, theme) {
        return BlocBuilder<LocaleCubit, Locale>(
          builder: (_, locale) {
            return _materialApp(theme, locale);
          },
        );
      },
    );
  }

  MaterialApp _materialApp(ThemeData theme, Locale locale) {
    return MaterialApp.router(
      title: kAppName,
      debugShowCheckedModeBanner: false,
      theme: theme,
      routerConfig: routes,
      locale: locale,
      supportedLocales: supportedLocale,
      localizationsDelegates: [
        AppLocalizations.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      localeResolutionCallback: (locale, supportedLocales) {
        for (var supportedLocale in supportedLocales) {
          if (supportedLocale.languageCode == locale?.languageCode) {
            return supportedLocale;
          }
        }
        // Return the first supported locale
        return supportedLocales.first;
      },
    );
  }
}


Path: lib\app\colors.dart
Code:
import 'package:flutter/material.dart';

class AppColors {
  const AppColors._();

  static const Color colorName = Color(0xFF8DC53F);

  // usage AppColors.colorName2[int]. [int] is optional
  static const MaterialColor colorName2 = MaterialColor(0xFF2196F3, <int, Color>{
    50: Color(0xFFE3F2FD),
    100: Color(0xFFBBDEFB),
    200: Color(0xFF90CAF9),
    300: Color(0xFF64B5F6),
    400: Color(0xFF42A5F5),
    500: Color(0xFF2196F3),
    600: Color(0xFF1E88E5),
    700: Color(0xFF1976D2),
    800: Color(0xFF1565C0),
    900: Color(0xFF0D47A1),
  });
}


Path: lib\app\flavor.dart
Code:
// usage: FlavorService.instance.config.name
// usage: FlavorService.instance.config.someThing

import '../configs/flavor_config.dart';

enum Flavor { dev, staging, prod }

class FlavorService {
  final Flavor flavor;
  final FlavorConfig config;

  FlavorService._({required this.flavor, required this.config});

  static FlavorService? _instance;

  static FlavorService get instance {
    if (_instance == null) {
      throw Exception('FlavorService not initialized. Call FlavorService.initialize() first.');
    }
    return _instance!;
  }

  static void initialize(Flavor flavor) {
    if (_instance != null) return;

    FlavorConfig config;
    switch (flavor) {
      case Flavor.dev:
        config = FlavorValues.dev;
        break;
      case Flavor.staging:
        config = FlavorValues.staging;
        break;
      case Flavor.prod:
        config = FlavorValues.prod;
        break;
    }

    _instance = FlavorService._(flavor: flavor, config: config);
  }
}


Path: lib\app\locale.dart
Code:
// usage: context.tr(I18nKeys.name)
// With param example: hello {name} -> hello Flutter Dev
// usage: context.tr(I18nKeys.greeting, {'name': 'Flutter Dev'})

import 'dart:async';
import 'dart:convert';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../configs/configs.dart';

part 'locale_key.dart';
// Define a Keys class

class AppLocalizations {
  final Locale locale;

  AppLocalizations(this.locale);

  static AppLocalizations? of(BuildContext context) {
    return Localizations.of<AppLocalizations>(context, AppLocalizations);
  }

  static String translate(BuildContext context, String key, [Map<String, String>? params]) {
    return AppLocalizations.of(context)?._translate(key, params) ?? key;
  }

  late Map<String, String> _localizedStrings;

  Future<bool> load() async {
    String jsonString = await rootBundle.loadString('assets/lang/${locale.languageCode}.json');
    Map<String, dynamic> jsonMap = json.decode(jsonString);

    _localizedStrings = jsonMap.map((key, value) {
      return MapEntry(key, value.toString());
    });

    return true;
  }

  String _translate(String key, [Map<String, String>? params]) {
    String translation = _localizedStrings[key] ?? key;

    if (params != null) {
      params.forEach((paramKey, paramValue) {
        translation = translation.replaceAll('{$paramKey}', paramValue);
      });
    }
    return translation;
  }

  static const LocalizationsDelegate<AppLocalizations> delegate = _AppLocalizationsDelegate();
}

class _AppLocalizationsDelegate extends LocalizationsDelegate<AppLocalizations> {
  const _AppLocalizationsDelegate();

  @override
  bool isSupported(Locale locale) {
    return supportedLocaleCode.contains(locale.languageCode);
  }

  @override
  Future<AppLocalizations> load(Locale locale) async {
    AppLocalizations localizations = AppLocalizations(locale);
    await localizations.load();
    return localizations;
  }

  @override
  bool shouldReload(_AppLocalizationsDelegate old) => false;
}

extension AppLocalizationsExt on BuildContext {
  String tr(String key, [Map<String, String>? params]) {
    return AppLocalizations.translate(this, key, params);
  }
}


Path: lib\app\locale_key.dart
Code:
part of 'locale.dart';

class I18nKeys {
  static const String appName = 'appName';
  static const String notFoundPageTitle = 'notFoundPageTitle';
  static const String goToHome = 'goToHome';
  static const String login = 'login';
  static const String register = 'register';
  static const String username = 'username';
  static const String password = 'password';
  static const String enterUsername = 'enterUsername';
  static const String enterPassword = 'enterPassword';
  static const String welcomeBack = 'welcomeBack';
  static const String or = 'or';
  static const String loginWithGoogle = 'loginWithGoogle';
  static const String loginWithFacebook = 'loginWithFacebook';
  static const String notHaveAccount = 'notHaveAccount';
  static const String registerAccount = 'registerAccount';
  static const String email = 'email';
  static const String confirmPassword = 'confirmPassword';
  static const String enterEmail = 'enterEmail';
  static const String enterConfirmPassword = 'enterConfirmPassword';
  static const String passwordsDontMatch = 'passwordsDontMatch';
  static const String continueLabel = 'continueLabel';
  static const String bookmarkedPosts = 'bookmarkedPosts';
  static const String noBookmarkedPosts = 'noBookmarkedPosts';
  static const String postDetail = 'postDetail';
  static const String editComment = 'editComment';
  static const String updateYourComment = 'updateYourComment';
  static const String cancel = 'cancel';
  static const String updateComment = 'updateComment';
  static const String deleteComment = 'deleteComment';
  static const String deleteCommentConfirm = 'deleteCommentConfirm';
  static const String deleteCommentConfirmAction = 'deleteCommentConfirmAction';
  static const String comments = 'comments';
  static const String addAComment = 'addAComment';
  static const String loginToAddComments = 'loginToAddComments';
  static const String noMoreList = 'noMoreList';
  static const String posts = 'posts';
  static const String search = 'search';
  static const String enterSearchTerms = 'enterSearchTerms';
  static const String home = 'home';
  static const String users = 'users';
  static const String settings = 'settings';
  static const String userProfile = 'userProfile';
  static const String changePassword = 'changePassword';
  static const String logout = 'logout';
  static const String theme = 'theme';
  static const String language = 'language';
  static const String english = 'english';
  static const String vietnamese = 'vietnamese';
  static const String enterNewPassword = 'enterNewPassword';
  static const String changePasswordAction = "changePasswordAction";
  static const String removeFriends = "removeFriends";
  static const String addFriends = "addFriends";
  static const String viewProfile = "viewProfile";
  static const String aboutMe = "aboutMe";
  static const String dateCreate = "dateCreate";
  static const String lastestUpdate = "lastestUpdate";
  static const String myProfile = "myProfile";
  static const String updateYourFullname = "updateYourFullname";
  static const String fullname = "fullname";
  static const String updateYourEmail = "updateYourEmail";
  static const String updateAboutMe = "updateAboutMe";
  static const String updateUser = "updateUser";
  static const String deletePost = "deletePost";
  static const String deletePostConfirm = "deletePostConfirm";
  static const String deletePostConfirmAction = "deletePostConfirmAction";
  static const String createPost = "createPost";
  static const String updatePost = "updatePost";
  static const String postTitle = "postTitle";
  static const String postBody = "postBody";
}


Path: lib\app\logs.dart
Code:
// usage: logService.d  (debug)
// usage: logService.i  (info)
// usage: logService.w  (warning)
// usage: logService.e  (error)
// usage: logService.f  (fatal)
// params (dynamic message, Object? error, StackTrace? stackTrace)

import 'dart:async';
import 'dart:io' as io;

import 'package:flutter/foundation.dart';
import 'package:logger/logger.dart';
// Conditional import skip path_provider if not web (path_provider 2.1.5 not support web yet)
import 'package:path_provider/path_provider.dart'
    if (dart.library.io) 'package:path_provider/path_provider.dart';

class FileLogOutput extends LogOutput {
  final String fileName;
  io.File? _logFile;
  io.IOSink? _sink;

  FileLogOutput({required this.fileName});

  @override
  Future<void> init() async {
    if (!kIsWeb) {
      final directory = await getApplicationDocumentsDirectory();
      final filePath = '${directory.path}/$fileName';
      _logFile = io.File(filePath);
      _sink = _logFile!.openWrite(mode: io.FileMode.append);
    }
  }

  @override
  void output(OutputEvent event) {
    if (_sink != null) {
      // Only write to file if _sink is initialized (not web)
      for (var line in event.lines) {
        _sink?.writeln(line);
      }
    }
  }

  @override
  Future<void> destroy() async {
    await _sink?.flush();
    await _sink?.close();
    _sink = null;
    _logFile = null; // Set _logFile to null after closing to prevent further use
  }
}

class LogService {
  static LogService? _instance;
  late final Logger _logger;
  final FileLogOutput? _fileOutput;

  // Private constructor (modified to accept optional FileLogOutput)
  LogService._internal(this._logger, [this._fileOutput]);

  // Static method to access the instance
  static Future<LogService> instance({String fileName = 'app_log.txt'}) async {
    if (_instance == null) {
      Logger logger;
      FileLogOutput? fileOutput;

      if (!kIsWeb) {
        fileOutput = FileLogOutput(fileName: fileName);
        await fileOutput.init();
        logger = Logger(
          printer: PrettyPrinter(),
          output: MultiOutput([ConsoleOutput(), fileOutput]),
        );
      } else {
        logger = Logger(printer: PrettyPrinter(), output: ConsoleOutput());
      }

      _instance = LogService._internal(logger, fileOutput);
    }
    return _instance!;
  }

  // Log methods
  void d(dynamic message, {Object? error, StackTrace? stackTrace}) {
    debugPrint(message);
    _logger.d(message, error: error, stackTrace: stackTrace);
  }

  void i(dynamic message, {Object? error, StackTrace? stackTrace}) {
    debugPrint(message);
    _logger.i(message, error: error, stackTrace: stackTrace);
  }

  void w(dynamic message, {Object? error, StackTrace? stackTrace}) {
    debugPrint(message);
    _logger.w(message, error: error, stackTrace: stackTrace);
  }

  void e(dynamic message, {Object? error, StackTrace? stackTrace}) {
    debugPrint(message);
    _logger.e(message, error: error, stackTrace: stackTrace);
  }

  void f(dynamic message, {Object? error, StackTrace? stackTrace}) {
    debugPrint(message);
    _logger.f(message, error: error, stackTrace: stackTrace);
  }

  // Close log file
  Future<void> close() async {
    await _fileOutput?.destroy();
    _instance = null;
  }
}


Path: lib\app\routes.dart
Code:
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

import '../core/pages/not_found_page.dart';
import '../features/auth/presentation/blocs/auth_bloc.dart';
import '../features/auth/presentation/pages/login_page.dart';
import '../features/auth/presentation/pages/register_page.dart';
import '../features/post/presentation/pages/bookmarked_posts_page.dart';
import '../features/post/presentation/pages/post_detail_page.dart';
import '../features/presentation/home/pages/home_page.dart';
import '../features/user/presentation/pages/user_profile_page.dart';
import '../injection_container.dart';

class Paths {
  static const String login = '/login';
  static const String register = '/register';
  static const String forgotPassword = '/forgot_password';
  static const String settings = '/settings';
  static const String home = '/home';
  static const String bookmarkedPost = '/posts/bookmarked';

  // routes have params
  static const String userProfile = '/user_profile';
  static const String postDetail = '/post_detail';
}

final routes = GoRouter(
  initialLocation: sl<AuthBloc>().state is AuthLoaded ? Paths.home : Paths.login,
  redirect: (context, state) {
    List<String> exclude = [Paths.register];

    final authBloc = sl<AuthBloc>();
    if (authBloc.state is AuthInitial) authBloc.add(GetLoggedInUserEvent());
    final isAuthenticated = authBloc.state is AuthLoaded;

    if (exclude.contains(state.uri.path)) return null;

    final isLoginPage = state.uri.path == Paths.login;
    return isAuthenticated && !isLoginPage ? null : Paths.login;
  },
  routes: [
    GoRoute(
      path: '${Paths.postDetail}/:postId',
      builder: (context, state) {
        final postIdParameters = state.pathParameters['postId'];
        final postId = postIdParameters ?? '';
        if (postId.isEmpty) return NotFoundPage();

        return PostDetailPage(postId: postId);
      },
    ),
    GoRoute(
      path: Paths.bookmarkedPost,
      builder: (context, state) {
        return BookmarkedPostsPage();
      },
    ),
    GoRoute(path: Paths.login, builder: (context, state) => const LoginPage()),
    GoRoute(path: Paths.home, builder: (context, state) => const HomePage()),
    GoRoute(path: Paths.register, builder: (context, state) => const RegisterPage()),
    GoRoute(
      path: Paths.forgotPassword,
      builder: (context, state) => const Scaffold(body: Center(child: Text('Forgot Password'))),
    ),

    GoRoute(
      path: '${Paths.userProfile}/:userId',
      builder: (context, state) {
        final userIdParameters = state.pathParameters['userId'];
        final userId = userIdParameters ?? '';
        if (userId.isEmpty) return NotFoundPage();

        return UserProfilePage(userId: userId);
      },
    ),

    GoRoute(
      path: Paths.settings,
      builder: (context, state) => const Scaffold(body: Center(child: Text('Settings'))),
    ),
  ],
  errorBuilder: (context, state) => const NotFoundPage(),
);


Path: lib\app\theme.dart
Code:
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class AppTheme {
  AppTheme._();

  static final ThemeData lightTheme = ThemeData(
    brightness: Brightness.light,
    textTheme: _poppinsTextTheme(ThemeData.light().textTheme),
    // ... other theme data
  );

  static final ThemeData darkTheme = ThemeData(
    brightness: Brightness.dark,
    textTheme: _poppinsTextTheme(ThemeData.dark().textTheme),
    // ... other theme data
  );

  static final ThemeData customTheme = ThemeData(
    brightness: Brightness.dark,
    colorSchemeSeed: Colors.green,
    textTheme: _poppinsTextTheme(ThemeData.dark().textTheme),
    // ... other theme data
  );

  static TextTheme _poppinsTextTheme(TextTheme base) {
    return GoogleFonts.poppinsTextTheme(base);
  }
}


Path: lib\app\cubits\cubits.dart
Code:
export 'locale_cubit.dart';
export 'logs_cubit.dart';
export 'theme_cubit.dart';


Path: lib\app\cubits\locale_cubit.dart
Code:
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:shared_preferences/shared_preferences.dart';

class LocaleCubit extends Cubit<Locale> {
  static const _localeKey = 'Locale';

  LocaleCubit() : super(const Locale('en')) {
    _loadInitialLocale();
  }

  Future<void> _loadInitialLocale() async {
    final prefs = await SharedPreferences.getInstance();
    final savedLocaleCode = prefs.getString(_localeKey);

    if (savedLocaleCode != null) {
      emit(Locale(savedLocaleCode));
    } else {
      emit(const Locale('en'));
    }
  }

  Future<void> setLocale(Locale newLocale) async {
    if (state == newLocale) return;

    emit(newLocale);

    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(_localeKey, newLocale.languageCode);
    } catch (e) {
      debugPrint('Error saving locale: $e');
    }
  }
}


Path: lib\app\cubits\logs_cubit.dart
Code:
import 'package:flutter/foundation.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../configs/app_config.dart';
import '../flavor.dart';
import '../logs.dart';

class LogCubit extends Cubit<void> {
  LogService? _logService;

  LogCubit() : super(null);

  Future<void> initialize() async {
    if (FlavorService.instance.config.enableSaveLog) {
      try {
        _logService = await LogService.instance(fileName: kLogFile);
        _logService!.i('LogService initialized');
      } catch (e) {
        debugPrint('Error initializing LogService: $e');
      }
    }
  }

  @override
  Future<void> close() async {
    super.close();
    if (_logService != null) {
      await _logService!.close();
      _logService = null;
      debugPrint('LogService closed');
    }
  }
}


Path: lib\app\cubits\theme_cubit.dart
Code:
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../theme.dart';

class ThemeCubit extends Cubit<ThemeData> {
  // default lightTheme
  ThemeCubit() : super(AppTheme.lightTheme) {
    _loadInitialTheme();
  }

  // Constants for theme keys
  static const String _themeKey = 'themeMode';

  static const String lightThemeKey = 'Light Theme';
  static const String darkThemeKey = 'Dark Theme';
  static const String customThemeKey = 'Custom Theme';

  Future<void> _loadInitialTheme() async {
    final prefs = await SharedPreferences.getInstance();
    final savedTheme = prefs.getString(_themeKey);

    if (savedTheme == darkThemeKey) {
      emit(AppTheme.darkTheme);
    } else if (savedTheme == customThemeKey) {
      emit(AppTheme.customTheme);
    } else {
      emit(AppTheme.lightTheme);
    }
  }

  Future<void> toggleTheme(String themeKey) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_themeKey, themeKey);

    switch (themeKey) {
      case lightThemeKey:
        emit(AppTheme.lightTheme);
        break;
      case darkThemeKey:
        emit(AppTheme.darkTheme);
        break;
      case customThemeKey:
        emit(AppTheme.customTheme);
        break;
    }
  }

  static String themeToString(ThemeData theme) {
    if (theme == AppTheme.lightTheme) return lightThemeKey;
    if (theme == AppTheme.darkTheme) return darkThemeKey;
    if (theme == AppTheme.customTheme) return customThemeKey;
    return 'Undefined Theme';
  }
}


Path: lib\configs\app_config.dart
Code:
const kAppName = 'Flutter Starter';
const kLogFile = 'flutter_starter_log.txt';


Path: lib\configs\configs.dart
Code:
export 'app_config.dart';
export 'flavor_config.dart';
export 'locale_config.dart';


Path: lib\configs\flavor_config.dart
Code:
import 'package:flutter/foundation.dart';

class FlavorConfig {
  final String name;
  final String baseUrl;
  final bool enableSaveLog;
  final int requestTimeout;

  FlavorConfig({
    required this.name,
    required this.baseUrl,
    required this.enableSaveLog,
    required this.requestTimeout,
  });

  // Helper methods
  // String get someThing => someValue + someValue2;
}

class FlavorValues {
  static final dev = FlavorConfig(
    name: 'Developer',
    baseUrl: kIsWeb ? 'http://localhost:3000/api/v1' : 'http://10.0.2.2:3000/api/v1',
    enableSaveLog: true,
    requestTimeout: 10,
  );

  static final staging = FlavorConfig(
    name: 'Staging',
    baseUrl: 'http://localhost:3001/api/v1',
    enableSaveLog: true,
    requestTimeout: 10,
  );

  static final prod = FlavorConfig(
    name: 'Production',
    baseUrl: 'http://localhost:3002/api/v1',
    enableSaveLog: false,
    requestTimeout: 10,
  );
}


Path: lib\configs\locale_config.dart
Code:
import 'package:flutter/material.dart';

const supportedLocale = [Locale('en'), Locale('vi')];
const supportedLocaleCode = ['en', 'vi'];


Path: lib\core\constants\api_endpoints.dart
Code:
class ApiEndpoints {
  static String login = '/login';
  static String register = '/register';
  static String verify = '/verify';
  static String users = '/users';
  static String posts = '/posts';
  static String comments = '/comments';

  static String getCommentsByPostId({required String postId}) => '$posts/$postId/comments';
  static String userFriendList(String userId) => '$users/$userId/friends';
  static String singleComment(String id) => '$comments/$id';
  static String singlePost(String id) => '$posts/$id';
  static String singleUser(String id) => '$users/$id';
  static String userDetail(String id) => '$users/$id/details';
  static String bookmarkPost({required String userId}) => '$users/$userId/bookmark';
  static String userPosts({required String userId}) => '$users/$userId/posts';
}


Path: lib\core\constants\api_mapping.dart
Code:
class UserApiMap {
  static const String kId = 'id';
  static const String kFullName = 'fullName';
  static const String kUserName = 'username';
  static const String kEmail = 'email';
  static const String kAvatar = 'avatar';
  static const String kCover = 'cover';
  static const String kSecret = 'secret';
  static const String kBookmarksId = 'bookmarkedPosts';
  static const String kFriendIds = 'friendIds';
  static const String kAbout = 'about';
}

class UserDetailApiMap {
  static const String kPosts = 'posts';
  static const String kComments = 'comments';
  static const String kFriends = 'friends';
}

class PostApiMap {
  static const String kId = 'id';
  static const String kUserId = 'userId';
  static const String kTitle = 'title';
  static const String kBody = 'body';
  static const String kImageUrl = 'imageUrl';
}

class CommentApiMap {
  static const String kId = 'id';
  static const String kPostId = 'postId';
  static const String kUser = 'user';
  static const String kBody = 'body';
}

const String kCreatedAt = 'createdAt';
const String kUpdatedAt = 'updatedAt';


Path: lib\core\constants\constants.dart
Code:
const String kServerFailureMessage = 'Server Failure';
const String kNoCacheFailureMessage = 'No Cache Failure';
const String kNoInternetFailureMessage = 'No Internet Connection';
const String kInvalidInputFailureMessage = 'Invalid Input';
const String kUnauthenticatedFailureMessage = 'Authenticated Failure';
const String kTimeoutFailure = 'Connection Error.  Check your internet connection';
const String kInvalidCredentialsFailureMessage = 'Invalid username or password.';

// const String kInvalidEmailFailureMessage = 'Invalid Email Format';
// const String kPasswordTooShortFailureMessage = 'Password is too short';
// const String kUsernameEmptyFailureMessage = 'Username cannot be empty';


Path: lib\core\constants\enum.dart
Code:
enum PaginationOrder { desc, asc }

extension PaginationOrderEnumExt on PaginationOrder? {
  String getString() {
    if (this == null) return 'desc';

    switch (this!) {
      case PaginationOrder.desc:
        return 'desc';
      case PaginationOrder.asc:
        return 'asc';
    }
  }
}


Path: lib\core\constants\pagination.dart
Code:
class PaginationStorage {
  int currentPage;
  int limit;
  bool hasMore;

  PaginationStorage({this.currentPage = 1, this.limit = 5, this.hasMore = true});

  PaginationStorage copyWith({int? currentPage, int? limit, bool? hasMore}) {
    return PaginationStorage(
      currentPage: currentPage ?? this.currentPage,
      limit: limit ?? this.limit,
      hasMore: hasMore ?? this.hasMore,
    );
  }
}


Path: lib\core\errors\dio_exception_handle.dart
Code:
part of 'exceptions.dart';

Never handleDioException(DioException e, StackTrace s, String at) {
  if (e.response != null) {
    final statusCode = e.response!.statusCode;
    final statusMessage = e.response!.statusMessage;

    switch (statusCode) {
      case 400:
        throw ServerException(
          message: statusMessage ?? 'Bad Request',
          statusCode: statusCode,
          stackTrace: s,
        );
      case 401:
        throw InvalidCredentialsException();
      case 403:
        throw UnauthenticatedException();
      case 404:
        throw ServerException(
          message: statusMessage ?? 'Not Found',
          statusCode: statusCode,
          stackTrace: s,
        );
      case 409:
        throw ServerException(
          message: statusMessage ?? 'Conflict',
          statusCode: statusCode,
          stackTrace: s,
        );
      case 500:
        throw ServerException(
          message: statusMessage ?? 'Internal Server Error',
          statusCode: statusCode,
          stackTrace: s,
        );
      default:
        throw ServerException(
          message: statusMessage ?? 'Server error',
          statusCode: statusCode,
          stackTrace: s,
        );
    }
  } else {
    if (e.type == DioExceptionType.connectionTimeout ||
        e.type == DioExceptionType.sendTimeout ||
        e.type == DioExceptionType.receiveTimeout ||
        e.type == DioExceptionType.connectionError) {
      throw TimeoutException();
    }
  }
  throw ServerException(message: 'Error at: $at: ${e.message}');
}


Path: lib\core\errors\exceptions.dart
Code:
import 'package:dio/dio.dart';

import '../constants/constants.dart';
import 'failures.dart';

part 'dio_exception_handle.dart';
part 'repository_exception_handle.dart';

class ServerException implements Exception {
  final String? message;
  final int? statusCode;
  final StackTrace? stackTrace;

  ServerException({this.message, this.statusCode, this.stackTrace});
}

extension ServerExceptionToFailure on ServerException {
  ServerFailure toFailure({String? message}) {
    return ServerFailure(
      message: message ?? this.message ?? kServerFailureMessage,
      code: statusCode?.toString() ?? '-1',
      stackTrace: stackTrace,
    );
  }
}

class TimeoutException implements Exception {
  final String? message;
  TimeoutException({this.message = kTimeoutFailure});
}

class CacheException implements Exception {
  final String? message;
  CacheException({this.message});
}

class InvalidCredentialsException implements Exception {
  final String message;
  InvalidCredentialsException({this.message = kInvalidCredentialsFailureMessage});
}

class UnauthenticatedException implements Exception {
  final String message;
  UnauthenticatedException({this.message = kUnauthenticatedFailureMessage});
}


Path: lib\core\errors\failures.dart
Code:
import 'package:equatable/equatable.dart';

import '../constants/constants.dart';

abstract class Failure extends Equatable {
  final String? message;
  final StackTrace? stackTrace;
  final String? code;
  const Failure({this.message, this.code, this.stackTrace});

  @override
  List<Object?> get props => [message, code, stackTrace];

  // @override
  // String toString() {
  //   return '(message: $message, code: $code)';
  // }
}

class ServerFailure extends Failure {
  const ServerFailure({super.message = kServerFailureMessage, super.code = '-1', super.stackTrace});

  @override
  List<Object?> get props => [message, code, stackTrace];
}

class AppFailure extends Failure {
  const AppFailure({super.message = kServerFailureMessage});

  @override
  List<Object?> get props => [message];
}

class NoCacheFailure extends Failure {
  const NoCacheFailure({super.message = kNoCacheFailureMessage, super.code, super.stackTrace});
}

class TimeoutFailure extends Failure {
  const TimeoutFailure({super.message = kTimeoutFailure, super.code, super.stackTrace});
}

class NoInternetFailure extends Failure {
  const NoInternetFailure({
    super.message = kNoInternetFailureMessage,
    super.code,
    super.stackTrace,
  });
}

class InvalidInputFailure extends Failure {
  const InvalidInputFailure({
    super.message = kInvalidInputFailureMessage,
    super.code,
    super.stackTrace,
  });
}

class UnauthenticatedFailure extends Failure {
  const UnauthenticatedFailure({
    super.message = kUnauthenticatedFailureMessage,
    super.stackTrace,
    super.code,
  });
}

class InvalidCredentialsFailure extends Failure {
  const InvalidCredentialsFailure({
    super.message = kInvalidCredentialsFailureMessage,
    super.stackTrace,
    super.code,
  });
}


Path: lib\core\errors\repository_exception_handle.dart
Code:
part of 'exceptions.dart';

Failure handleRepositoryException(Object e) {
  if (e is ServerException) {
    return e.toFailure();
  } else if (e is InvalidCredentialsException) {
    return InvalidCredentialsFailure();
  } else if (e is UnauthenticatedException) {
    return UnauthenticatedFailure();
  } else if (e is TimeoutException) {
    return TimeoutFailure();
  } else {
    return ServerFailure(message: e.toString());
  }
}


Path: lib\core\extensions\build_content_extensions.dart
Code:
import 'package:flutter/material.dart';

extension BuildContextExt on BuildContext {
  // usage: context.textTheme
  TextTheme get textTheme => Theme.of(this).textTheme;
  // usage: context.width
  double get width => MediaQuery.of(this).size.width;
  // usage: context.height
  double get height => MediaQuery.of(this).size.height;
  // usage: context.widthF(0.2)
  double widthF(double factor) => width * factor;
  // usage: context.heightF(0.2)
  double heightF(double factor) => height * factor;
  // usage: context.isMobile
  bool get isMobile => width < 768;

  // Safe area
  EdgeInsets get paddingOf => MediaQuery.paddingOf(this);
  // use at home page, get height after substract safe area, appbar height, bottom nav height
  // usage : context.safeHeight. (-n because still left scroll, if need scroll more add + n)
  double get homeSafeHeight =>
      height -
      paddingOf.top -
      paddingOf.bottom -
      AppBar().preferredSize.height -
      kBottomNavigationBarHeight -
      5;
  // safe height without bottom nav height
  double get safeHeightNoBottom => homeSafeHeight + kBottomNavigationBarHeight;

  // usage: context.colorScheme
  ColorScheme get colorScheme => Theme.of(this).colorScheme;

  // usage: context.snakebar("text")
  void snakebar(String text) =>
      ScaffoldMessenger.of(this).showSnackBar(SnackBar(content: Text(text)));
}


Path: lib\core\extensions\color_extensions.dart
Code:
import 'package:flutter/material.dart';

extension ColorExt on Color {
  // usage: Colors.black.opacityColor(0.2)
  Color opacityColor(double opacityValue) {
    final alpha = (opacityValue.clamp(0.0, 1.0) * 255).round();
    return withAlpha(alpha);
  }
}


Path: lib\core\extensions\num_extension.dart
Code:
import 'package:flutter/material.dart';

extension IntExt on int {
  // usage: 20.toShortString
  String get toShortString {
    if (this >= 1000000000) {
      return '${(this / 1000000000).toStringAsFixed(1)} B';
    } else if (this >= 1000000) {
      return '${(this / 1000000).toStringAsFixed(1)} M';
    } else if (this >= 1000) {
      return '${(this / 1000).toStringAsFixed(1)} K';
    }
    return toString();
  }

  EdgeInsets get eiAll => EdgeInsets.all(toDouble());
  EdgeInsets get eiHori => EdgeInsets.symmetric(horizontal: toDouble());
  EdgeInsets get eiVert => EdgeInsets.symmetric(vertical: toDouble());

  BorderRadius get radius => BorderRadius.circular(toDouble());
}


Path: lib\core\extensions\scroll_controller.dart
Code:
import 'package:flutter/material.dart';

extension ScrollControllerExt on ScrollController {
  // usage: scrollController.isBottom
  bool get isBottom {
    if (!hasClients) return false;
    final maxScroll = position.maxScrollExtent;
    final currentScroll = offset;
    return currentScroll >= maxScroll - 50;
  }
}


Path: lib\core\extensions\widget_extensions.dart
Code:
import 'package:flutter/material.dart';

extension DoubleWidgetExt on num {
  // usage: 20.sb()
  Widget sbW() => SizedBox(width: toDouble());
  Widget sbH() => SizedBox(height: toDouble());
  Widget sb() => SizedBox(width: toDouble(), height: toDouble());
}


Path: lib\core\network\network_info.dart
Code:
import 'package:internet_connection_checker_plus/internet_connection_checker_plus.dart';

abstract class NetworkInfo {
  Future<bool> get isConnected;
}

class NetworkInfoImpl implements NetworkInfo {
  final InternetConnection connectionChecker;

  NetworkInfoImpl(this.connectionChecker);

  @override
  Future<bool> get isConnected => connectionChecker.hasInternetAccess;
}


Path: lib\core\pages\not_found_page.dart
Code:
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

import '../../app/routes.dart';

class NotFoundPage extends StatelessWidget {
  const NotFoundPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Text(
              "Oops! The page you're looking for doesn't exist.",
              style: TextStyle(fontSize: 18),
            ),
            const SizedBox(height: 20),
            FilledButton(
              onPressed: () => context.go(Paths.home),
              style: FilledButton.styleFrom(padding: EdgeInsets.all(10)),
              child: const Text('Go to Home'),
            ),
          ],
        ),
      ),
    );
  }
}


Path: lib\core\usecase\params.dart
Code:
import 'package:equatable/equatable.dart';

import '../constants/enum.dart';

class NoParams extends Equatable {
  @override
  List<Object?> get props => [];
}

class PaginationParams extends Equatable {
  final int page;
  final int limit;
  final PaginationOrder order;

  const PaginationParams({
    required this.page,
    required this.limit,
    this.order = PaginationOrder.desc,
  });

  @override
  List<Object?> get props => [page, limit];
}

class IdParams extends Equatable {
  final String id;
  const IdParams({required this.id});

  @override
  List<Object?> get props => [id];
}

class ListIdParams extends Equatable {
  final List<String> ids;
  const ListIdParams({required this.ids});

  @override
  List<Object?> get props => [ids];
}


Path: lib\core\usecase\usecase.dart
Code:
import 'package:dartz/dartz.dart';

import '../errors/failures.dart';

export 'params.dart';

abstract class UseCase<Type, Params> {
  Future<Either<Failure, Type>> call(Params params);
}


Path: lib\core\utils\num_utils.dart
Code:
int intParse({required dynamic value, int fallbackValue = 0}) {
  return value is num ? value.toInt() : (int.tryParse(value.toString()) ?? fallbackValue);
}

double doubleParse({required dynamic value, double fallbackValue = 0}) {
  return value is num ? value.toDouble() : (double.tryParse(value.toString()) ?? fallbackValue);
}


Path: lib\core\utils\string_utils.dart
Code:
String timeAgo(DateTime dateTime) {
  final now = DateTime.now();
  final difference = now.difference(dateTime);

  if (difference.inMinutes < 1) {
    return 'Just now';
  } else if (difference.inMinutes < 60) {
    return '${difference.inMinutes}m ago';
  } else if (difference.inHours < 24) {
    return '${difference.inHours}h ago';
  } else if (difference.inDays < 7) {
    return '${difference.inDays}d ago';
  } else {
    // Display day and month
    return '${dateTime.day} ${_monthName(dateTime.month)}';
  }
}

String _monthName(int month) {
  switch (month) {
    case 1:
      return 'Jan';
    case 2:
      return 'Feb';
    case 3:
      return 'Mar';
    case 4:
      return 'Apr';
    case 5:
      return 'May';
    case 6:
      return 'Jun';
    case 7:
      return 'Jul';
    case 8:
      return 'Aug';
    case 9:
      return 'Sep';
    case 10:
      return 'Oct';
    case 11:
      return 'Nov';
    case 12:
      return 'Dec';
    default:
      return 'Invalid Month';
  }
}


Path: lib\core\utils\utils.dart
Code:
export 'num_utils.dart';
export 'string_utils.dart';


Path: lib\core\widgets\cache_image.dart
Code:
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';

class CachedImage extends StatelessWidget {
  final String imageUrl;
  final double? width;
  final double? height;
  final BoxFit fit;
  final Widget? placeholder;
  final Widget? errorWidget;
  final Duration? fadeInDuration;
  final Duration? fadeOutDuration;
  final Color? color;
  final BlendMode? colorBlendMode;
  final Alignment alignment;
  final ImageRepeat repeat;
  final FilterQuality filterQuality;
  final BorderRadius? borderRadius;

  const CachedImage({
    super.key,
    required this.imageUrl,
    this.width,
    this.borderRadius,
    this.height,
    this.fit = BoxFit.cover,
    this.placeholder,
    this.errorWidget,
    this.fadeInDuration = const Duration(milliseconds: 500),
    this.fadeOutDuration = const Duration(milliseconds: 1000),
    this.color,
    this.colorBlendMode,
    this.alignment = Alignment.center,
    this.repeat = ImageRepeat.noRepeat,
    this.filterQuality = FilterQuality.medium,
  });

  @override
  Widget build(BuildContext context) {
    return ClipRRect(
      borderRadius: borderRadius ?? BorderRadius.zero,
      child: CachedNetworkImage(
        key: ValueKey<String>(imageUrl),
        imageUrl: imageUrl,
        width: width,
        height: height,
        fit: fit,
        filterQuality: filterQuality,
        fadeInDuration: fadeInDuration ?? const Duration(milliseconds: 500),
        fadeOutDuration: fadeOutDuration ?? const Duration(milliseconds: 1000),
        color: color,
        colorBlendMode: colorBlendMode,
        alignment: alignment,
        repeat: repeat,
        placeholder:
            (context, url) => placeholder ?? const Center(child: CircularProgressIndicator()),
        errorWidget:
            (context, url, error) => Image.network(
              imageUrl,
              width: width,
              height: height,
              fit: fit,
              filterQuality: filterQuality,
              color: color,
              colorBlendMode: colorBlendMode,
              alignment: alignment,
              repeat: repeat,
            ),
      ),
    );
  }
}


Path: lib\core\widgets\has_more_incaditor.dart
Code:
import 'package:flutter/material.dart';

import '../../app/locale.dart';
import '../../core/extensions/build_content_extensions.dart';

Widget hasMoreWidget(BuildContext context, bool hasMore) =>
    hasMore
        ? const Padding(
          padding: EdgeInsets.symmetric(vertical: 16),
          child: Center(child: CircularProgressIndicator()),
        )
        : Padding(
          padding: const EdgeInsets.only(top: 16),
          child: Center(
            child: Text(
              context.tr(I18nKeys.noMoreList),
              style: context.textTheme.bodyMedium!.copyWith(fontWeight: FontWeight.w600),
            ),
          ),
        );


Path: lib\core\widgets\layout.dart
Code:
import 'package:flutter/material.dart';

import '../extensions/build_content_extensions.dart';
import '../extensions/num_extension.dart';

Widget safeWrapContainer(
  BuildContext context,
  ScrollController scrollController,
  Widget child, {
  Border? border,
  bool hasBottomBar = true,
}) {
  return SingleChildScrollView(
    controller: scrollController,
    physics: AlwaysScrollableScrollPhysics(),
    child: Center(
      child: Container(
        constraints: BoxConstraints(
          maxWidth: 1000,
          minHeight: hasBottomBar ? context.homeSafeHeight + 5 : context.safeHeightNoBottom + 6,
        ),
        decoration: BoxDecoration(
          border: border,
          borderRadius: 8.radius,
          color: context.colorScheme.surfaceBright,
        ),
        padding: 10.eiAll,
        child: child,
      ),
    ),
  );
}


Path: lib\core\widgets\post_item.dart
Code:
import 'package:flutter/material.dart';

import '../../features/post/domain/entities/post_entity.dart';
import '../extensions/build_content_extensions.dart';
import '../extensions/num_extension.dart';
import '../extensions/widget_extensions.dart';
import '../utils/string_utils.dart';
import 'cache_image.dart';

class PostItem extends StatelessWidget {
  const PostItem({
    super.key,
    required this.post,
    this.callback,
    this.border,
    this.isDetail = false,
    this.isEditable = false,
    this.onEditPostCallback,
    this.onDeletePostCallback,
  });
  final PostEntity post;
  final Border? border;
  final Function()? callback;
  final bool isDetail;
  final bool isEditable;
  final Function(PostEntity)? onEditPostCallback;
  final Function(PostEntity)? onDeletePostCallback;

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: callback,
      child: Container(
        decoration: BoxDecoration(
          border: isDetail ? null : border ?? Border.all(color: context.colorScheme.outline),
          borderRadius: 12.radius,
        ),
        padding: 20.eiAll,
        child: (context.isMobile || isDetail) ? _columnPost(context) : _rowPost(context),
      ),
    );
  }

  Row _rowPost(BuildContext context) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisSize: MainAxisSize.min,
      children: [
        CachedImage(
          imageUrl: post.imageUrl,
          placeholder: SizedBox(
            width: 280,
            height: 150,
            child: Center(child: CircularProgressIndicator()),
          ),
          width: 280,
          height: 150,
        ),
        20.sbW(),
        Flexible(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,

                children: [
                  Expanded(
                    child: Text(
                      post.title,
                      softWrap: true,
                      style: context.textTheme.titleLarge,
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                  if (isEditable) ...editActionButton(),
                ],
              ),
              Text(
                timeAgo(post.updatedAt),
                style: TextStyle(color: context.colorScheme.onSurfaceVariant),
              ),
              20.sbH(),
              Text(
                post.body,
                style: context.textTheme.bodyMedium,
                maxLines: 4,
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
        ),
      ],
    );
  }

  Column _columnPost(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        CachedImage(
          imageUrl: post.imageUrl,
          placeholder: SizedBox(
            height: 250,
            width: double.infinity,
            child: Center(child: CircularProgressIndicator()),
          ),
          height: 250,
          width: double.infinity,
        ),
        20.sbH(),
        Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Expanded(
              child: Text(
                post.title,
                style: context.textTheme.titleLarge,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
            ),
            if (isEditable) ...editActionButton(),
          ],
        ),
        Text(
          timeAgo(post.updatedAt),
          style: TextStyle(color: context.colorScheme.onSurfaceVariant),
        ),
        20.sbH(),
        Text(
          post.body,
          style: context.textTheme.bodyLarge,
          maxLines: isDetail ? null : 5,
          overflow: isDetail ? TextOverflow.visible : TextOverflow.ellipsis,
        ),
      ],
    );
  }

  List<Widget> editActionButton() => [
    IconButton(
      onPressed: () => onEditPostCallback != null ? onEditPostCallback!(post) : null,
      icon: Icon(Icons.edit),
    ),
    16.sbW(),
    IconButton(
      onPressed: () => onDeletePostCallback != null ? onDeletePostCallback!(post) : null,
      icon: Icon(Icons.delete),
    ),
  ];
}


Path: lib\core\widgets\widgets.dart
Code:
export 'cache_image.dart';
export 'layout.dart';


Path: lib\features\auth\data\datasources\auth_local_data_source.dart
Code:
import 'dart:convert';

import 'package:flutter_secure_storage/flutter_secure_storage.dart';

import '../models/auth_model.dart';

abstract class AuthLocalDataSource {
  Future<void> cacheAuth(AuthModel auth);
  Future<AuthModel?> getCachedAuth();
  Future<void> clearCachedAuth();
}

class AuthLocalDataSourceImpl implements AuthLocalDataSource {
  final FlutterSecureStorage secureStorage;
  static const kCachedAuth = 'kCachedAuth';

  AuthLocalDataSourceImpl({required this.secureStorage});

  @override
  Future<void> cacheAuth(AuthModel auth) =>
      secureStorage.write(key: kCachedAuth, value: json.encode(auth.toJson()));

  @override
  Future<AuthModel?> getCachedAuth() async {
    final jsonString = await secureStorage.read(key: kCachedAuth);

    if (jsonString != null) {
      try {
        return AuthModel.fromJson(jsonDecode(jsonString));
      } catch (_) {
        return null;
      }
    }
    return null;
  }

  @override
  Future<void> clearCachedAuth() => secureStorage.delete(key: kCachedAuth);
}


Path: lib\features\auth\data\datasources\auth_remote_data_source.dart
Code:
import 'package:dio/dio.dart';

import '../../../../core/constants/api_endpoints.dart';
import '../../../../core/errors/exceptions.dart';
import '../../domain/usecases/login_usecase.dart';
import '../../domain/usecases/register_usecase.dart';
import '../../domain/usecases/update_password_usecase.dart';
import '../models/auth_model.dart';

abstract class AuthRemoteDataSource {
  Future<AuthModel> login(LoginParams params);
  Future<AuthModel> register(RegisterParams params);
  Future<bool> verifySecret(String secret);
  Future<void> updateUserPassword(UpdateUserPasswordParams params);
}

class AuthRemoteDataSourceImpl implements AuthRemoteDataSource {
  final Dio dio;

  AuthRemoteDataSourceImpl({required this.dio});

  @override
  Future<AuthModel> login(LoginParams params) async {
    try {
      final response = await dio.post(
        ApiEndpoints.login,
        data: {'username': params.username, 'password': params.password},
      );

      return AuthModel.fromJson(response.data);
    } on DioException catch (e, s) {
      handleDioException(e, s, 'login(LoginParams params)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }

  @override
  Future<AuthModel> register(RegisterParams params) async {
    try {
      final response = await dio.post(
        ApiEndpoints.register,
        data: {'username': params.userName, 'email': params.email, 'password': params.password},
      );
      return AuthModel.fromJson(response.data);
    } on DioException catch (e, s) {
      handleDioException(e, s, 'register(RegisterParams params)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }

  @override
  Future<bool> verifySecret(String secret) async {
    try {
      final response = await dio.post(ApiEndpoints.verify, data: {'secret': secret});
      return response.statusCode == 200;
    } catch (e) {
      return false;
    }
  }

  @override
  Future<void> updateUserPassword(UpdateUserPasswordParams params) async {
    try {
      await dio.patch(
        ApiEndpoints.singleUser(params.userId),
        data: {'password': params.newPassword},
      );
      return;
    } on DioException catch (e, s) {
      handleDioException(e, s, 'updateUserPassword(UpdateUserPasswordParam user)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }
}


Path: lib\features\auth\data\models\auth_model.dart
Code:
import '../../../../core/constants/api_mapping.dart';
import '../../domain/entities/auth_entity.dart';

class AuthModel extends AuthEntity {
  const AuthModel({
    required super.id,
    required super.fullName,
    required super.userName,
    required super.email,
    required super.secret,
  });

  factory AuthModel.fromJson(Map<String, dynamic> json) {
    return AuthModel(
      id: json[UserApiMap.kId],
      fullName: json[UserApiMap.kFullName],
      userName: json[UserApiMap.kUserName],
      email: json[UserApiMap.kEmail],
      secret: json[UserApiMap.kSecret],
    );
  }

  factory AuthModel.fromEntity(AuthEntity auth) {
    return AuthModel(
      id: auth.id,
      fullName: auth.fullName,
      userName: auth.userName,
      email: auth.email,
      secret: auth.secret,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      UserApiMap.kId: id,
      UserApiMap.kFullName: fullName,
      UserApiMap.kUserName: userName,
      UserApiMap.kEmail: email,
      UserApiMap.kSecret: secret,
    };
  }

  AuthModel copyWith({
    String? id,
    String? fullName,
    String? userName,
    String? email,
    String? secret,
  }) {
    return AuthModel(
      id: id ?? this.id,
      fullName: fullName ?? this.fullName,
      userName: userName ?? this.userName,
      email: email ?? this.email,
      secret: secret ?? this.secret,
    );
  }
}


Path: lib\features\auth\data\repositories\auth_repository_impl.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/exceptions.dart';
import '../../../../core/errors/failures.dart';
import '../../../../core/network/network_info.dart';
import '../../domain/entities/auth_entity.dart';
import '../../domain/repositories/auth_repository.dart';
import '../../domain/usecases/login_usecase.dart';
import '../../domain/usecases/register_usecase.dart';
import '../../domain/usecases/update_password_usecase.dart';
import '../datasources/auth_local_data_source.dart';
import '../datasources/auth_remote_data_source.dart';

class AuthRepositoryImpl implements AuthRepository {
  final AuthRemoteDataSource remoteDataSource;
  final AuthLocalDataSource localDataSource;
  final NetworkInfo networkInfo;

  AuthRepositoryImpl({
    required this.remoteDataSource,
    required this.localDataSource,
    required this.networkInfo,
  });

  @override
  Future<Either<Failure, AuthEntity>> login(LoginParams params) async {
    if (await networkInfo.isConnected) {
      try {
        final remoteAuth = await remoteDataSource.login(params);
        await localDataSource.cacheAuth(remoteAuth);
        return Right(remoteAuth);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    }
    return Left(NoInternetFailure());
  }

  @override
  Future<Either<Failure, AuthEntity>> register(RegisterParams params) async {
    if (await networkInfo.isConnected) {
      try {
        final remoteAuth = await remoteDataSource.register(params);
        await localDataSource.cacheAuth(remoteAuth);
        return Right(remoteAuth);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    }
    return Left(NoInternetFailure());
  }

  @override
  Future<Either<Failure, AuthEntity>> getLoggedInUser() async {
    final localAuth = await localDataSource.getCachedAuth();
    if (localAuth != null) {
      final verifyResult = await verifySecret(localAuth);
      return verifyResult ? Right(localAuth) : Left(UnauthenticatedFailure());
    } else {
      return Left(NoCacheFailure());
    }
  }

  @override
  Future<Either<Failure, void>> logout() async {
    await localDataSource.clearCachedAuth();
    return const Right(unit);
  }

  Future<bool> verifySecret(AuthEntity auth) async {
    if (await networkInfo.isConnected) {
      try {
        final isVerified = await remoteDataSource.verifySecret(auth.secret);
        return isVerified;
      } catch (e) {
        return false;
      }
    } else {
      return false;
    }
  }

  @override
  Future<Either<Failure, void>> updateUserPassword(UpdateUserPasswordParams params) async {
    if (await networkInfo.isConnected) {
      try {
        await remoteDataSource.updateUserPassword(params);
        await localDataSource.clearCachedAuth();

        return const Right(unit);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    } else {
      return Left(NoInternetFailure());
    }
  }
}


Path: lib\features\auth\domain\entities\auth_entity.dart
Code:
import 'package:equatable/equatable.dart';

class AuthEntity extends Equatable {
  final String id;
  final String fullName;
  final String userName;
  final String email;
  final String secret;

  const AuthEntity({
    required this.id,
    required this.fullName,
    required this.userName,
    required this.email,
    required this.secret,
  });

  @override
  List<Object> get props => [id, fullName, userName, email, secret];
}


Path: lib\features\auth\domain\repositories\auth_repository.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../entities/auth_entity.dart';
import '../usecases/login_usecase.dart';
import '../usecases/register_usecase.dart';
import '../usecases/update_password_usecase.dart';

abstract class AuthRepository {
  Future<Either<Failure, AuthEntity>> login(LoginParams params);
  Future<Either<Failure, AuthEntity>> register(RegisterParams params);
  Future<Either<Failure, AuthEntity>> getLoggedInUser();
  Future<Either<Failure, void>> logout();
  Future<Either<Failure, void>> updateUserPassword(UpdateUserPasswordParams params);
}


Path: lib\features\auth\domain\usecases\get_logged_in_user_usecase.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/auth_entity.dart';
import '../repositories/auth_repository.dart';

class GetLoggedInUserUseCase implements UseCase<AuthEntity, NoParams> {
  final AuthRepository repository;

  GetLoggedInUserUseCase(this.repository);

  @override
  Future<Either<Failure, AuthEntity>> call(NoParams params) async {
    return await repository.getLoggedInUser();
  }
}


Path: lib\features\auth\domain\usecases\login_usecase.dart
Code:
import 'package:dartz/dartz.dart';
import 'package:equatable/equatable.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/auth_entity.dart';
import '../repositories/auth_repository.dart';

class LoginUseCase implements UseCase<AuthEntity, LoginParams> {
  final AuthRepository repository;

  LoginUseCase(this.repository);

  @override
  Future<Either<Failure, AuthEntity>> call(LoginParams params) async {
    return await repository.login(params);
  }
}

class LoginParams extends Equatable {
  final String username;
  final String password;

  const LoginParams({required this.username, required this.password});

  @override
  List<Object> get props => [username, password];
}


Path: lib\features\auth\domain\usecases\logout_usecase.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../repositories/auth_repository.dart';

class LogoutUseCase implements UseCase<void, NoParams> {
  final AuthRepository repository;

  LogoutUseCase(this.repository);

  @override
  Future<Either<Failure, void>> call(NoParams params) async {
    return await repository.logout();
  }
}


Path: lib\features\auth\domain\usecases\register_usecase.dart
Code:
import 'package:dartz/dartz.dart';
import 'package:equatable/equatable.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/auth_entity.dart';
import '../repositories/auth_repository.dart';

class RegisterUseCase implements UseCase<AuthEntity, RegisterParams> {
  final AuthRepository repository;

  RegisterUseCase(this.repository);

  @override
  Future<Either<Failure, AuthEntity>> call(RegisterParams params) async {
    String? validate = _validateParam(params);
    if (validate != null) return Left(InvalidInputFailure(message: validate));

    return await repository.register(params);
  }
}

class RegisterParams extends Equatable {
  final String userName;
  final String password;
  final String email;

  const RegisterParams({required this.userName, required this.password, required this.email});

  @override
  List<Object> get props => [userName, password, email];
}

String? _validateParam(RegisterParams params) {
  if (params.userName.length < 6) return 'Username must be at least 6 characters.';

  if (params.email.isEmpty || !params.email.contains('@')) return 'Invalid email address.';

  if (params.password.length < 6) return 'Password must be at least 6 characters.';

  return null;
}


Path: lib\features\auth\domain\usecases\update_password_usecase.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../repositories/auth_repository.dart';

class UpdatePasswordUseCase implements UseCase<void, UpdateUserPasswordParams> {
  final AuthRepository repository;

  UpdatePasswordUseCase(this.repository);

  @override
  Future<Either<Failure, void>> call(UpdateUserPasswordParams params) async {
    return await repository.updateUserPassword(params);
  }
}

class UpdateUserPasswordParams {
  final String userId;
  final String newPassword;

  UpdateUserPasswordParams({required this.newPassword, required this.userId});
}


Path: lib\features\auth\presentation\blocs\auth_bloc.dart
Code:
import 'package:dartz/dartz.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../app/logs.dart';
import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/params.dart';
import '../../domain/entities/auth_entity.dart';
import '../../domain/usecases/get_logged_in_user_usecase.dart';
import '../../domain/usecases/login_usecase.dart';
import '../../domain/usecases/logout_usecase.dart';
import '../../domain/usecases/register_usecase.dart';
import '../../domain/usecases/update_password_usecase.dart';

part 'auth_event.dart';
part 'auth_state.dart';

class AuthBloc extends Bloc<AuthEvent, AuthState> {
  final LoginUseCase loginUseCase;
  final RegisterUseCase registerUseCase;
  final GetLoggedInUserUseCase getLoggedInUserUseCase;
  final LogoutUseCase logoutUseCase;
  final UpdatePasswordUseCase updatePasswordUseCase;
  final LogService logService;

  AuthBloc({
    required this.loginUseCase,
    required this.registerUseCase,
    required this.getLoggedInUserUseCase,
    required this.logoutUseCase,
    required this.updatePasswordUseCase,
    required this.logService,
  }) : super(AuthInitial()) {
    on<LoginEvent>(_onLogin);
    on<RegisterEvent>(_onRegister);
    on<GetLoggedInUserEvent>(_onGetLoggedInUser);
    on<LogoutEvent>(_onLogout);
    on<UpdatePasswordEvent>(_onUpdateUserPassword);
  }

  Future<void> _onUpdateUserPassword(UpdatePasswordEvent event, Emitter<AuthState> emit) async {
    final result = await updatePasswordUseCase(
      UpdateUserPasswordParams(userId: event.userId, newPassword: event.newPassword),
    );

    result.fold(
      (failure) {
        logService.w(
          '$failure occur at _onGetUserById(GetUserByIdEvent event, Emitter<UserState> emit)',
        );
        emit(AuthError(failure: failure));
      },
      (_) {
        emit(AuthInitial());
      },
    );
  }

  Future<void> _onLogin(LoginEvent event, Emitter<AuthState> emit) async {
    emit(AuthLoading());
    final result = await loginUseCase(event.params);
    emit(_mapResultToAuthLoaded(result, '_onLogin(LoginEvent event, Emitter<AuthState> emit)'));
  }

  Future<void> _onRegister(RegisterEvent event, Emitter<AuthState> emit) async {
    emit(AuthLoading());
    final result = await registerUseCase(event.params);
    emit(
      _mapResultToAuthLoaded(result, '_onRegister(RegisterEvent event, Emitter<AuthState> emit)'),
    );
  }

  Future<void> _onGetLoggedInUser(GetLoggedInUserEvent event, Emitter<AuthState> emit) async {
    emit(AuthLoading());
    final result = await getLoggedInUserUseCase(NoParams());
    emit(
      _mapResultToAuthLoaded(
        result,
        '_onGetLoggedInUser(GetLoggedInUserEvent event, Emitter<AuthState> emit)',
      ),
    );
  }

  Future<void> _onLogout(LogoutEvent event, Emitter<AuthState> emit) async {
    emit(AuthLoading());
    final result = await logoutUseCase(NoParams());
    result.fold((failure) {
      logService.w('$failure occur at _onLogout(LogoutEvent event, Emitter<AuthState> emit)');
      emit(AuthError(failure: failure));
    }, (_) => emit(AuthInitial()));
  }

  AuthState _mapResultToAuthLoaded(Either<Failure, AuthEntity> result, String errorAt) {
    return result.fold(
      (failure) {
        if (errorAt.contains('GetLoggedInUserEvent')) {
          return AuthInitial();
        }
        logService.w('$failure occur at $errorAt');
        return AuthError(failure: failure);
      },
      (auth) {
        return AuthLoaded(auth: auth);
      },
    );
  }
}


Path: lib\features\auth\presentation\blocs\auth_event.dart
Code:
part of 'auth_bloc.dart';

abstract class AuthEvent extends Equatable {
  const AuthEvent();

  @override
  List<Object> get props => [];
}

class LoginEvent extends AuthEvent {
  final LoginParams params;
  const LoginEvent({required this.params});

  @override
  List<Object> get props => [params];
}

class RegisterEvent extends AuthEvent {
  final RegisterParams params;
  const RegisterEvent({required this.params});

  @override
  List<Object> get props => [params];
}

class GetLoggedInUserEvent extends AuthEvent {}

class LogoutEvent extends AuthEvent {}

class UpdatePasswordEvent extends AuthEvent {
  final String userId;
  final String newPassword;

  const UpdatePasswordEvent({required this.newPassword, required this.userId});
}


Path: lib\features\auth\presentation\blocs\auth_state.dart
Code:
part of 'auth_bloc.dart';

abstract class AuthState extends Equatable {
  const AuthState();

  @override
  List<Object> get props => [];
}

class AuthInitial extends AuthState {}

class AuthLoading extends AuthState {}

class AuthLoaded extends AuthState {
  final AuthEntity auth;

  const AuthLoaded({required this.auth});

  @override
  List<Object> get props => [auth];
}

class AuthError extends AuthState {
  final Failure failure;

  const AuthError({required this.failure});

  @override
  List<Object> get props => [failure];
}

class AuthVerified extends AuthState {}


Path: lib\features\auth\presentation\pages\login_page.dart
Code:
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';

import '../../../../app/locale.dart';
import '../../../../app/routes.dart';
import '../../../../core/extensions/build_content_extensions.dart';
import '../../../../core/extensions/num_extension.dart';
import '../../../../core/extensions/widget_extensions.dart';
import '../../../../injection_container.dart';
import '../../domain/usecases/login_usecase.dart';
import '../blocs/auth_bloc.dart';
import '../widgets/widgets.dart';

class LoginPage extends StatefulWidget {
  const LoginPage({super.key});

  @override
  State<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends State<LoginPage> {
  final _formKey = GlobalKey<FormState>();
  final _username = TextEditingController();
  final _password = TextEditingController();
  late AuthBloc _authBloc;

  @override
  void initState() {
    _authBloc = sl<AuthBloc>();
    super.initState();
  }

  @override
  void dispose() {
    _username.dispose();
    _password.dispose();
    super.dispose();
  }

  void _login() {
    if (_formKey.currentState!.validate()) {
      _authBloc.add(
        LoginEvent(params: LoginParams(username: _username.text, password: _password.text)),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: BlocConsumer<AuthBloc, AuthState>(
        listener: (_, state) {
          if (state is AuthError) {
            context.snakebar(state.failure.message ?? 'Login Failed');
          } else if (state is AuthLoaded) {
            context.go(Paths.home);
          }
        },
        builder: (_, state) {
          if (state is AuthLoading) {
            return const Center(child: CircularProgressIndicator());
          } else {
            // Show login form
            return AuthSafeWrap(
              child: Padding(
                padding: 16.eiAll,
                child: Form(
                  key: _formKey,
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Center(
                        child: Text(
                          context.tr(I18nKeys.welcomeBack),
                          textAlign: TextAlign.center,
                          style: context.textTheme.headlineMedium,
                        ),
                      ),
                      36.sb(),
                      TextFormField(
                        controller: _username,
                        decoration: InputDecoration(labelText: context.tr(I18nKeys.username)),
                        validator:
                            (value) => value!.isEmpty ? context.tr(I18nKeys.enterUsername) : null,
                      ),
                      16.sb(),
                      TextFormField(
                        controller: _password,
                        decoration: InputDecoration(labelText: context.tr(I18nKeys.password)),
                        obscureText: true,
                        validator:
                            (value) => value!.isEmpty ? context.tr(I18nKeys.enterPassword) : null,
                      ),
                      24.sb(),
                      AuthActionButton(text: context.tr(I18nKeys.login), onPressed: _login),
                      12.sb(),
                      Text(
                        context.tr(I18nKeys.or),
                        style: context.textTheme.titleMedium!.copyWith(
                          color: context.colorScheme.onSecondaryContainer,
                        ),
                      ),
                      12.sb(),
                      SocialSignin(
                        icon: Image.asset('assets/images/ic-google.png', width: 30),
                        text: context.tr(I18nKeys.loginWithGoogle),
                      ),
                      20.sb(),
                      SocialSignin(
                        icon: Image.asset('assets/images/ic-facebook.png', width: 30),
                        text: context.tr(I18nKeys.loginWithGoogle),
                      ),
                      24.sb(),
                      TextButton(
                        onPressed: () => context.push(Paths.register),
                        child: Text(
                          context.tr(I18nKeys.notHaveAccount),
                          style: TextStyle(
                            fontWeight: FontWeight.w500,
                            fontSize: 18,
                            color: context.colorScheme.onSurfaceVariant,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            );
          }
        },
      ),
    );
  }
}


Path: lib\features\auth\presentation\pages\register_page.dart
Code:
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';

import '../../../../app/locale.dart';
import '../../../../app/routes.dart';
import '../../../../core/extensions/build_content_extensions.dart';
import '../../../../core/extensions/widget_extensions.dart';
import '../../../../injection_container.dart';
import '../../domain/usecases/register_usecase.dart';
import '../blocs/auth_bloc.dart';
import '../widgets/widgets.dart';

class RegisterPage extends StatefulWidget {
  const RegisterPage({super.key});

  @override
  State<RegisterPage> createState() => _RegisterPageState();
}

class _RegisterPageState extends State<RegisterPage> {
  final GlobalKey<FormState> _signUpGlobalKey = GlobalKey<FormState>();
  final _name = TextEditingController();
  final _email = TextEditingController();
  final _password = TextEditingController();
  final _confirmPassword = TextEditingController();
  bool _showPassword = true;

  late AuthBloc _authBloc;

  @override
  void initState() {
    _authBloc = sl<AuthBloc>();
    super.initState();
  }

  @override
  void dispose() {
    _name.dispose();
    _email.dispose();
    _password.dispose();
    _confirmPassword.dispose();
    super.dispose();
  }

  void _register() {
    if (_signUpGlobalKey.currentState!.validate()) {
      if (_password.text != _confirmPassword.text) {
        context.snakebar(context.tr(I18nKeys.passwordsDontMatch));
        return;
      }

      _authBloc.add(
        RegisterEvent(
          params: RegisterParams(
            userName: _name.text,
            email: _email.text,
            password: _password.text,
          ),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: BlocConsumer<AuthBloc, AuthState>(
        // Use BlocConsumer
        listener: (context, state) {
          if (state is AuthError) {
            context.snakebar(state.failure.message ?? 'Registration Failed');
          } else if (state is AuthLoaded) {
            context.go(Paths.home);
          }
        },
        builder: (context, state) {
          if (state is AuthLoading) {
            return const Center(child: CircularProgressIndicator());
          } else {
            // Show registration form
            return AuthSafeWrap(
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Form(key: _signUpGlobalKey, child: _buildForm(context)),
              ),
            );
          }
        },
      ),
    );
  }

  Column _buildForm(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Back Icon Button
        GestureDetector(
          onTap: () {
            context.pop();
          },
          child: const Icon(Icons.chevron_left, size: 40),
        ),
        24.sb(),
        Text(
          context.tr(I18nKeys.registerAccount),
          style: TextStyle(fontSize: 20, fontWeight: FontWeight.w600),
        ),
        30.sb(),
        Column(
          children: [
            TextFormField(
              controller: _name,
              decoration: InputDecoration(hintText: context.tr(I18nKeys.username)),
              validator: (value) => value!.isEmpty ? context.tr(I18nKeys.enterUsername) : null,
            ),

            16.sb(),
            TextFormField(
              controller: _email,
              decoration: InputDecoration(hintText: context.tr(I18nKeys.email)),
              validator:
                  (value) =>
                      value!.isEmpty || !value.contains('@')
                          ? context.tr(I18nKeys.enterEmail)
                          : null,
            ),

            16.sb(),
            TextFormField(
              controller: _password,
              obscureText: _showPassword,
              decoration: InputDecoration(
                hintText: context.tr(I18nKeys.password),
                suffixIcon: GestureDetector(
                  onTap: () {
                    setState(() => _showPassword = !_showPassword);
                  },
                  child: Icon(
                    _showPassword ? Icons.visibility_off_outlined : Icons.visibility_outlined,
                  ),
                ),
              ),
              validator: (value) => value!.isEmpty ? context.tr(I18nKeys.enterPassword) : null,
            ),

            16.sb(),
            TextFormField(
              controller: _confirmPassword,
              obscureText: _showPassword,
              decoration: InputDecoration(hintText: context.tr(I18nKeys.confirmPassword)),
              validator:
                  (value) => value!.isEmpty ? context.tr(I18nKeys.enterConfirmPassword) : null,
            ),
            30.sb(),

            AuthActionButton(text: context.tr(I18nKeys.continueLabel), onPressed: _register),
          ],
        ),
      ],
    );
  }
}


Path: lib\features\auth\presentation\widgets\widgets.dart
Code:
import 'package:flutter/material.dart';

import '../../../../core/extensions/build_content_extensions.dart';
import '../../../../core/extensions/num_extension.dart';

class AuthSafeWrap extends StatelessWidget {
  final Widget child;
  const AuthSafeWrap({super.key, required this.child});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: SingleChildScrollView(
        child: Container(
          constraints: BoxConstraints(maxWidth: 450),
          padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 40),
          decoration: BoxDecoration(
            border:
                context.isMobile ? null : Border.all(color: context.colorScheme.onSurfaceVariant),
            borderRadius: 8.radius,
            color: context.colorScheme.surfaceBright,
          ),
          child: child,
        ),
      ),
    );
  }
}

class SocialSignin extends StatelessWidget {
  final void Function()? onPressed;
  final Widget icon;
  final String text;
  const SocialSignin({super.key, this.onPressed, required this.icon, required this.text});

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: onPressed ?? () {},
      style: TextButton.styleFrom(
        maximumSize: const Size(300, 60),
        backgroundColor: const Color(0xFFEDEEF0),
        padding: 10.eiAll,
      ),
      child: Padding(
        padding: 10.eiAll,
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceAround,
          children: [
            icon,
            Text(text, style: context.textTheme.bodyLarge!.copyWith(color: Colors.black)),
          ],
        ),
      ),
    );
  }
}

class AuthActionButton extends StatelessWidget {
  final String text;
  final void Function()? onPressed;
  const AuthActionButton({super.key, required this.text, this.onPressed});

  @override
  Widget build(BuildContext context) {
    return TextButton(
      onPressed: onPressed,
      style: TextButton.styleFrom(
        minimumSize: const Size(double.infinity, 55),
        backgroundColor: const Color(0xFF265AE8),
      ),
      child: Text(text, style: context.textTheme.bodyLarge!.copyWith(color: Colors.white)),
    );
  }
}


Path: lib\features\comment\data\datasources\comment_remote_data_source.dart
Code:
import 'package:dio/dio.dart';

import '../../../../core/constants/api_endpoints.dart';
import '../../../../core/constants/enum.dart';
import '../../../../core/errors/exceptions.dart';
import '../../domain/usecases/add_comment_usecase.dart';
import '../../domain/usecases/get_comments_by_post_id_usecase.dart';
import '../models/comment_model.dart';

abstract class CommentRemoteDataSource {
  Future<List<CommentModel>> getCommentsByPostId(GetCommentsParams params);
  Future<CommentModel> addComment(AddCommentParams params);
  Future<CommentModel> updateComment(CommentModel comment);
  Future<void> deleteComment(CommentModel comment);
}

class CommentRemoteDataSourceImpl implements CommentRemoteDataSource {
  final Dio dio;
  CommentRemoteDataSourceImpl({required this.dio});

  @override
  Future<List<CommentModel>> getCommentsByPostId(GetCommentsParams params) async {
    try {
      final response = await dio.get(
        ApiEndpoints.getCommentsByPostId(postId: params.postId),
        queryParameters: {
          '_page': params.page,
          '_limit': params.limit,
          '_sort': 'updatedAt',
          '_order': params.order.getString(),
        },
      );
      return (response.data as List).map((e) => CommentModel.fromJson(e)).toList();
    } on DioException catch (e, s) {
      handleDioException(e, s, 'getCommentsByPostId(String postId)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }

  @override
  Future<CommentModel> addComment(AddCommentParams params) async {
    try {
      final response = await dio.post(
        ApiEndpoints.getCommentsByPostId(postId: params.postId),
        data: {'userId': params.userId, 'body': params.body},
      );
      return CommentModel.fromJson(response.data);
    } on DioException catch (e, s) {
      handleDioException(e, s, 'addComment(String postId, String userId, String body)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }

  @override
  Future<CommentModel> updateComment(CommentModel comment) async {
    try {
      final response = await dio.patch(
        ApiEndpoints.singleComment(comment.id),
        data: {'userId': comment.user.id, 'body': comment.body},
      );
      return CommentModel.fromJson(response.data);
    } on DioException catch (e, s) {
      handleDioException(e, s, 'updateComment(CommentModel comment)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }

  @override
  Future<void> deleteComment(CommentModel comment) async {
    try {
      await dio.delete(ApiEndpoints.singleComment(comment.id), data: {'userId': comment.user.id});
      return;
    } on DioException catch (e, s) {
      handleDioException(e, s, 'deleteComment(CommentModel comment)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }
}


Path: lib\features\comment\data\models\comment_model.dart
Code:
import '../../../../core/constants/api_mapping.dart';
import '../../../user/data/models/user_model.dart';
import '../../../user/domain/entities/user_entity.dart';
import '../../domain/entities/comment_entity.dart';

class CommentModel extends CommentEntity {
  const CommentModel({
    required super.id,
    required super.postId,
    required super.user,
    required super.body,
    required super.createdAt,
    required super.updatedAt,
  });

  factory CommentModel.fromJson(Map<String, dynamic> json) {
    return CommentModel(
      id: json[CommentApiMap.kId] as String,
      postId: json[CommentApiMap.kPostId] as String,
      user: UserModel.fromJson(json[CommentApiMap.kUser]),
      body: json[CommentApiMap.kBody] as String,
      createdAt: DateTime.parse(json[kCreatedAt] as String),
      updatedAt: DateTime.parse(json[kUpdatedAt] as String),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      CommentApiMap.kId: id,
      CommentApiMap.kPostId: postId,
      CommentApiMap.kUser: UserModel.fromEntity(user).toJson(),
      CommentApiMap.kBody: body,
      kCreatedAt: createdAt.toIso8601String(),
      kUpdatedAt: updatedAt.toIso8601String(),
    };
  }

  factory CommentModel.fromEntity(CommentEntity comment) {
    return CommentModel(
      id: comment.id,
      postId: comment.postId,
      user: UserModel.fromEntity(comment.user),
      body: comment.body,
      createdAt: comment.createdAt,
      updatedAt: comment.updatedAt,
    );
  }

  @override
  CommentModel copyWith({
    String? id,
    String? postId,
    UserEntity? user,
    String? body,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return CommentModel(
      id: id ?? this.id,
      postId: postId ?? this.postId,
      user: user ?? this.user,
      body: body ?? this.body,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}


Path: lib\features\comment\data\repositories\comment_repository_impl.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/exceptions.dart';
import '../../../../core/errors/failures.dart';
import '../../../../core/network/network_info.dart';
import '../../domain/entities/comment_entity.dart';
import '../../domain/repositories/comment_repository.dart';
import '../../domain/usecases/add_comment_usecase.dart';
import '../../domain/usecases/get_comments_by_post_id_usecase.dart';
import '../datasources/comment_remote_data_source.dart';
import '../models/comment_model.dart';

class CommentRepositoryImpl implements CommentRepository {
  final CommentRemoteDataSource remoteDataSource;
  final NetworkInfo networkInfo;

  CommentRepositoryImpl({required this.remoteDataSource, required this.networkInfo});

  @override
  Future<Either<Failure, List<CommentEntity>>> getCommentsByPostId(GetCommentsParams params) async {
    if (await networkInfo.isConnected) {
      try {
        final comments = await remoteDataSource.getCommentsByPostId(params);
        return Right(comments);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    } else {
      return Left(NoInternetFailure());
    }
  }

  @override
  Future<Either<Failure, CommentEntity>> addComment(AddCommentParams params) async {
    if (await networkInfo.isConnected) {
      try {
        final comment = await remoteDataSource.addComment(params);
        return Right(comment);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    } else {
      return Left(NoInternetFailure());
    }
  }

  @override
  Future<Either<Failure, CommentEntity>> updateComment(CommentEntity params) async {
    if (await networkInfo.isConnected) {
      try {
        final comment = await remoteDataSource.updateComment(CommentModel.fromEntity(params));
        return Right(comment);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    } else {
      return Left(NoInternetFailure());
    }
  }

  @override
  Future<Either<Failure, void>> deleteComment(CommentEntity params) async {
    if (await networkInfo.isConnected) {
      try {
        await remoteDataSource.deleteComment(CommentModel.fromEntity(params));
        return const Right(unit);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    } else {
      return Left(NoInternetFailure());
    }
  }
}


Path: lib\features\comment\domain\entities\comment_entity.dart
Code:
import 'package:equatable/equatable.dart';

import '../../../user/domain/entities/user_entity.dart';

class CommentEntity extends Equatable {
  final String id;
  final String postId;
  final UserEntity user;
  final String body;
  final DateTime createdAt;
  final DateTime updatedAt;

  const CommentEntity({
    required this.id,
    required this.postId,
    required this.user,
    required this.body,
    required this.createdAt,
    required this.updatedAt,
  });

  @override
  List<Object?> get props => [id, postId, user, body, createdAt, updatedAt];

  CommentEntity copyWith({
    String? id,
    String? postId,
    UserEntity? user,
    String? body,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return CommentEntity(
      id: id ?? this.id,
      postId: postId ?? this.postId,
      user: user ?? this.user,
      body: body ?? this.body,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}


Path: lib\features\comment\domain\repositories\comment_repository.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../entities/comment_entity.dart';
import '../usecases/add_comment_usecase.dart';
import '../usecases/get_comments_by_post_id_usecase.dart';

abstract class CommentRepository {
  Future<Either<Failure, List<CommentEntity>>> getCommentsByPostId(GetCommentsParams params);
  Future<Either<Failure, CommentEntity>> addComment(AddCommentParams params);
  Future<Either<Failure, CommentEntity>> updateComment(CommentEntity params);
  Future<Either<Failure, void>> deleteComment(CommentEntity params);
}


Path: lib\features\comment\domain\usecases\add_comment_usecase.dart
Code:
import 'package:dartz/dartz.dart';
import 'package:equatable/equatable.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/comment_entity.dart';
import '../repositories/comment_repository.dart';

class AddCommentUseCase implements UseCase<CommentEntity, AddCommentParams> {
  final CommentRepository repository;

  AddCommentUseCase(this.repository);

  @override
  Future<Either<Failure, CommentEntity>> call(AddCommentParams params) async {
    return await repository.addComment(params);
  }
}

class AddCommentParams extends Equatable {
  final String postId;
  final String userId;
  final String body;

  const AddCommentParams({required this.postId, required this.userId, required this.body});

  @override
  List<Object?> get props => [postId, userId, body];
}


Path: lib\features\comment\domain\usecases\delete_comment_usecase.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/comment_entity.dart';
import '../repositories/comment_repository.dart';

class DeleteCommentUseCase implements UseCase<void, CommentEntity> {
  final CommentRepository repository;

  DeleteCommentUseCase(this.repository);

  @override
  Future<Either<Failure, void>> call(CommentEntity commentEntity) async {
    return await repository.deleteComment(commentEntity);
  }
}


Path: lib\features\comment\domain\usecases\get_comments_by_post_id_usecase.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/comment_entity.dart';
import '../repositories/comment_repository.dart';

class GetCommentsByPostIdUseCase implements UseCase<List<CommentEntity>, GetCommentsParams> {
  final CommentRepository repository;

  GetCommentsByPostIdUseCase(this.repository);

  @override
  Future<Either<Failure, List<CommentEntity>>> call(GetCommentsParams params) async {
    return await repository.getCommentsByPostId(params);
  }
}

class GetCommentsParams extends PaginationParams {
  final String postId;

  const GetCommentsParams({
    required this.postId,
    required super.page,
    required super.limit,
    super.order,
  });
}


Path: lib\features\comment\domain\usecases\update_comment_usecase.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/comment_entity.dart';
import '../repositories/comment_repository.dart';

class UpdateCommentUseCase implements UseCase<CommentEntity, CommentEntity> {
  final CommentRepository repository;

  UpdateCommentUseCase(this.repository);

  @override
  Future<Either<Failure, CommentEntity>> call(CommentEntity commentEntity) async {
    return await repository.updateComment(commentEntity);
  }
}


Path: lib\features\comment\presentation\blocs\comment_bloc.dart
Code:
import 'package:equatable/equatable.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../app/logs.dart';
import '../../../../core/constants/pagination.dart';
import '../../../../core/errors/failures.dart';
import '../../domain/entities/comment_entity.dart';
import '../../domain/usecases/add_comment_usecase.dart';
import '../../domain/usecases/delete_comment_usecase.dart';
import '../../domain/usecases/get_comments_by_post_id_usecase.dart';
import '../../domain/usecases/update_comment_usecase.dart';

part 'comment_event.dart';
part 'comment_state.dart';

class CommentBloc extends Bloc<CommentEvent, CommentState> {
  final GetCommentsByPostIdUseCase getCommentsByPostId;
  final AddCommentUseCase addComment;
  final UpdateCommentUseCase updateComment;
  final DeleteCommentUseCase deleteComment;
  final LogService logService;

  CommentBloc({
    required this.getCommentsByPostId,
    required this.addComment,
    required this.updateComment,
    required this.deleteComment,
    required this.logService,
  }) : super(CommentInitial()) {
    on<GetCommentsEvent>(_onGetComments);
    on<AddCommentEvent>(_onAddComment);
    on<UpdateCommentEvent>(_onUpdateComment);
    on<DeleteCommentEvent>(_onDeleteComment);
  }

  PaginationStorage _getCommentsPS = PaginationStorage().copyWith(limit: 2);
  String _currentPostId = '';

  void _onGetComments(GetCommentsEvent event, Emitter<CommentState> emit) async {
    if (event.postId != _currentPostId) _getCommentsPS = PaginationStorage().copyWith(limit: 2);
    _currentPostId = event.postId;

    final result = await getCommentsByPostId(
      GetCommentsParams(postId: event.postId, page: _getCommentsPS.currentPage, limit: 2),
    );

    result.fold(
      (failure) {
        logService.w(
          '$failure occur at _onGetComments(GetCommentsEvent event, Emitter<CommentState> emit)',
        );
        return emit(CommentError(failure: failure));
      },
      (comments) {
        _handleGetListComments(comments: comments, emit: emit, ps: _getCommentsPS);
      },
    );
  }

  void _handleGetListComments({
    required List<CommentEntity> comments,
    required PaginationStorage ps,
    required Emitter<CommentState> emit,
  }) {
    if (comments.isEmpty) {
      ps.hasMore = false;
      if (state is CommentsLoaded) {
        emit((state as CommentsLoaded).copyWith(hasMore: false));
        return;
      } else {
        emit(CommentsLoaded(comments: [], hasMore: false));
        return;
      }
    }

    if (ps.currentPage == 1 && comments.length < ps.limit) ps.hasMore = false;
    ps.currentPage++;

    if (state is CommentsLoaded) {
      emit((state as CommentsLoaded).copyWith(comments: comments));
      return;
    } else {
      emit(CommentsLoaded(comments: comments, hasMore: ps.hasMore));
      return;
    }
  }

  void _onAddComment(AddCommentEvent event, Emitter<CommentState> emit) async {
    if (state is CommentsLoaded) {
      final result = await addComment(
        AddCommentParams(postId: event.postId, userId: event.userId, body: event.body),
      );

      result.fold(
        (failure) {
          logService.w(
            '$failure occur at _onAddComment(AddCommentEvent event, Emitter<CommentState> emit)',
          );
          emit(CommentError(failure: failure));
        },
        (comment) {
          if ((state as CommentsLoaded).comments.isEmpty) {
            emit(CommentsLoaded(hasMore: false, comments: [comment]));
            return;
          }
          emit((state as CommentsLoaded).copyWith(comments: [comment], isInsert: true));
        },
      );
    }
  }

  void _onUpdateComment(UpdateCommentEvent event, Emitter<CommentState> emit) async {
    final currentState = state;
    if (currentState is CommentsLoaded) {
      final result = await updateComment(event.comment);

      result.fold(
        (failure) {
          logService.w(
            '$failure occur at _onUpdateComment(UpdateCommentEvent event, Emitter<CommentState> emit)',
          );
          emit(CommentError(failure: failure));
        },
        (updatedComment) {
          final updatedComments =
              currentState.comments.map((comment) {
                return comment.id == updatedComment.id ? updatedComment : comment;
              }).toList();
          emit(CommentsLoaded(comments: updatedComments, hasMore: currentState.hasMore));
        },
      );
    }
  }

  void _onDeleteComment(DeleteCommentEvent event, Emitter<CommentState> emit) async {
    final currentState = state;
    if (currentState is CommentsLoaded) {
      final result = await deleteComment(event.comment);

      result.fold(
        (failure) {
          logService.w(
            '$failure occur at _onDeleteComment(DeleteCommentEvent event, Emitter<CommentState> emit)',
          );
          emit(CommentError(failure: failure));
        },
        (_) {
          final updatedComments =
              currentState.comments.where((comment) => comment.id != event.comment.id).toList();
          emit(CommentsLoaded(comments: updatedComments, hasMore: currentState.hasMore));
        },
      );
    }
  }
}


Path: lib\features\comment\presentation\blocs\comment_event.dart
Code:
part of 'comment_bloc.dart';

abstract class CommentEvent extends Equatable {
  const CommentEvent();
  @override
  List<Object?> get props => [];
}

class GetCommentsEvent extends CommentEvent {
  final String postId;
  const GetCommentsEvent({required this.postId});
  @override
  List<Object?> get props => [postId];
}

class AddCommentEvent extends CommentEvent {
  final String postId;
  final String userId;
  final String body;

  const AddCommentEvent({required this.postId, required this.userId, required this.body});
  @override
  List<Object?> get props => [postId, userId, body];
}

class UpdateCommentEvent extends CommentEvent {
  final CommentEntity comment;

  const UpdateCommentEvent({required this.comment});
  @override
  List<Object?> get props => [comment];
}

class DeleteCommentEvent extends CommentEvent {
  final CommentEntity comment;

  const DeleteCommentEvent({required this.comment});
  @override
  List<Object?> get props => [comment];
}


Path: lib\features\comment\presentation\blocs\comment_state.dart
Code:
part of 'comment_bloc.dart';

abstract class CommentState extends Equatable {
  const CommentState();
  @override
  List<Object?> get props => [];
}

class CommentInitial extends CommentState {}

class CommentsLoaded extends CommentState {
  final List<CommentEntity> comments;
  final bool hasMore;

  const CommentsLoaded({required this.comments, required this.hasMore});

  @override
  List<Object> get props => [comments, hasMore];

  CommentsLoaded copyWith({List<CommentEntity>? comments, bool? hasMore, bool isInsert = false}) {
    return CommentsLoaded(
      comments:
          comments != null
              ? isInsert
                  ? [...comments, ...this.comments]
                  : [...this.comments, ...comments]
              : this.comments,
      hasMore: hasMore ?? this.hasMore,
    );
  }
}

class CommentError extends CommentState {
  final Failure failure;

  const CommentError({required this.failure});
}


Path: lib\features\post\data\datasources\post_remote_data_source.dart
Code:
import 'package:dio/dio.dart';

import '../../../../core/constants/api_endpoints.dart';
import '../../../../core/constants/api_mapping.dart';
import '../../../../core/constants/enum.dart';
import '../../../../core/errors/exceptions.dart';
import '../../../../core/usecase/params.dart';
import '../../domain/usecases/create_post_usecase.dart';
import '../../domain/usecases/get_posts_by_user_id_usecase.dart';
import '../../domain/usecases/search_posts_usecase.dart';
import '../models/post_model.dart';

abstract class PostRemoteDataSource {
  Future<List<PostModel>> getAllPosts(PaginationParams params);
  Future<List<PostModel>> getPostsByUserId(GetPostsByUserIdParams params);
  Future<PostModel> getPostById(String id);
  Future<PostModel> createPost(CreatePostParams params);
  Future<PostModel> updatePost(PostModel post);
  Future<void> deletePost(String id);
  Future<List<PostModel>> searchPosts(PaginationSearchPostParams params);
  Future<List<PostModel>> getPostsByIds(ListIdParams params);
}

class PostRemoteDataSourceImpl implements PostRemoteDataSource {
  final Dio dio;

  PostRemoteDataSourceImpl({required this.dio});

  @override
  Future<List<PostModel>> getAllPosts(PaginationParams params) async {
    try {
      final response = await dio.get(
        ApiEndpoints.posts,
        queryParameters: {
          '_page': params.page,
          '_limit': params.limit,
          '_sort': 'updatedAt',
          '_order': params.order.getString(),
        },
      );
      List<dynamic> data = response.data;
      return data.map((e) => PostModel.fromJson(e)).toList();
    } on DioException catch (e, s) {
      handleDioException(e, s, 'getAllPosts(PaginationParams params)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }

  @override
  Future<PostModel> getPostById(String id) async {
    try {
      final response = await dio.get(ApiEndpoints.singlePost(id));
      return PostModel.fromJson(response.data);
    } on DioException catch (e, s) {
      handleDioException(e, s, 'getPostById(String id)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }

  @override
  Future<PostModel> createPost(CreatePostParams params) async {
    try {
      final response = await dio.post(
        ApiEndpoints.posts,
        data: {
          PostApiMap.kUserId: params.userId,
          PostApiMap.kTitle: params.title,
          PostApiMap.kBody: params.body,
        },
      );
      return PostModel.fromJson(response.data);
    } on DioException catch (e, s) {
      handleDioException(e, s, 'createPost(PostModel post)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }

  @override
  Future<PostModel> updatePost(PostModel post) async {
    try {
      final response = await dio.put(ApiEndpoints.singlePost(post.id), data: post.toJson());
      return PostModel.fromJson(response.data);
    } on DioException catch (e, s) {
      handleDioException(e, s, 'updatePost(PostModel post)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }

  @override
  Future<void> deletePost(String id) async {
    try {
      await dio.delete(ApiEndpoints.singlePost(id));
    } on DioException catch (e, s) {
      handleDioException(e, s, 'deletePost(String id)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }

  @override
  Future<List<PostModel>> searchPosts(PaginationSearchPostParams params) async {
    try {
      final response = await dio.get(
        ApiEndpoints.posts,
        queryParameters: {
          'q': params.search,
          '_page': params.page,
          '_limit': params.limit,
          '_sort': 'updatedAt',
          '_order': params.order.getString(),
        },
      );
      final List<dynamic> data = response.data;
      return data.map((e) => PostModel.fromJson(e)).toList();
    } on DioException catch (e, s) {
      handleDioException(e, s, 'searchPosts(PaginationWithSearchParams params)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }

  @override
  Future<List<PostModel>> getPostsByIds(ListIdParams params) async {
    try {
      final response = await dio.get(ApiEndpoints.posts, queryParameters: {'id': params.ids});
      final List<dynamic> data = response.data;
      return data.map((e) => PostModel.fromJson(e)).toList();
    } on DioException catch (e, s) {
      handleDioException(e, s, 'getPostsByIds(List<int> ids)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }

  @override
  Future<List<PostModel>> getPostsByUserId(GetPostsByUserIdParams params) async {
    try {
      final response = await dio.get(
        ApiEndpoints.userPosts(userId: params.userId),
        queryParameters: {
          '_page': params.page,
          '_limit': params.limit,
          '_sort': 'updatedAt',
          '_order': params.order.getString(),
        },
      );
      List<dynamic> data = response.data;
      return data.map((e) => PostModel.fromJson(e)).toList();
    } on DioException catch (e, s) {
      handleDioException(e, s, 'getAllUserPosts(GetAllUserPostsParams params)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }
}


Path: lib\features\post\data\models\post_model.dart
Code:
import '../../../../core/constants/api_mapping.dart';
import '../../domain/entities/post_entity.dart';

class PostModel extends PostEntity {
  const PostModel({
    required super.id,
    required super.userId,
    required super.title,
    required super.body,
    required super.imageUrl,
    required super.createdAt,
    required super.updatedAt,
  });

  factory PostModel.fromJson(Map<String, dynamic> json) {
    return PostModel(
      id: json[PostApiMap.kId] as String,
      userId: json[PostApiMap.kUserId] as String,
      title: json[PostApiMap.kTitle] as String,
      body: json[PostApiMap.kBody] as String,
      imageUrl: json[PostApiMap.kImageUrl] as String,
      createdAt: DateTime.parse(json[kCreatedAt] as String),
      updatedAt: DateTime.parse(json[kUpdatedAt] as String),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      PostApiMap.kId: id,
      PostApiMap.kUserId: userId,
      PostApiMap.kTitle: title,
      PostApiMap.kBody: body,
      PostApiMap.kImageUrl: imageUrl,
      kCreatedAt: createdAt.toIso8601String(),
      kUpdatedAt: updatedAt.toIso8601String(),
    };
  }

  factory PostModel.fromEntity(PostEntity post) {
    return PostModel(
      id: post.id,
      userId: post.userId,
      title: post.title,
      body: post.body,
      imageUrl: post.imageUrl,
      createdAt: post.createdAt,
      updatedAt: post.updatedAt,
    );
  }

  @override
  PostModel copyWith({
    String? id,
    String? userId,
    String? title,
    String? body,
    String? imageUrl,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return PostModel(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      title: title ?? this.title,
      body: body ?? this.body,
      imageUrl: imageUrl ?? this.imageUrl,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}


Path: lib\features\post\data\repositories\post_repository_impl.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/exceptions.dart';
import '../../../../core/errors/failures.dart';
import '../../../../core/network/network_info.dart';
import '../../../../core/usecase/usecase.dart';
import '../../domain/entities/post_entity.dart';
import '../../domain/repositories/post_repository.dart';
import '../../domain/usecases/create_post_usecase.dart';
import '../../domain/usecases/get_posts_by_user_id_usecase.dart';
import '../../domain/usecases/search_posts_usecase.dart';
import '../datasources/post_remote_data_source.dart';
import '../models/post_model.dart';

class PostRepositoryImpl implements PostRepository {
  final PostRemoteDataSource remoteDataSource;
  final NetworkInfo networkInfo;

  PostRepositoryImpl({required this.remoteDataSource, required this.networkInfo});

  @override
  Future<Either<Failure, List<PostEntity>>> getAllPosts(PaginationParams params) async {
    if (await networkInfo.isConnected) {
      try {
        final posts = await remoteDataSource.getAllPosts(params);
        return Right(posts);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    } else {
      return Left(NoInternetFailure());
    }
  }

  @override
  Future<Either<Failure, PostEntity>> getPostById(IdParams params) async {
    if (await networkInfo.isConnected) {
      try {
        final remotePost = await remoteDataSource.getPostById(params.id);
        return Right(remotePost);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    } else {
      return Left(NoInternetFailure());
    }
  }

  @override
  Future<Either<Failure, PostEntity>> createPost(CreatePostParams params) async {
    if (await networkInfo.isConnected) {
      try {
        final remotePost = await remoteDataSource.createPost(params);
        return Right(remotePost);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    } else {
      return Left(NoInternetFailure());
    }
  }

  @override
  Future<Either<Failure, PostEntity>> updatePost(PostEntity post) async {
    if (await networkInfo.isConnected) {
      try {
        final postModel = PostModel.fromEntity(post);
        final remotePost = await remoteDataSource.updatePost(postModel);
        return Right(remotePost);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    } else {
      return Left(NoInternetFailure());
    }
  }

  @override
  Future<Either<Failure, void>> deletePost(PostEntity post) async {
    if (await networkInfo.isConnected) {
      try {
        await remoteDataSource.deletePost(post.id);
        return const Right(unit);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    } else {
      return Left(NoInternetFailure());
    }
  }

  @override
  Future<Either<Failure, List<PostEntity>>> searchPosts(PaginationSearchPostParams params) async {
    if (await networkInfo.isConnected) {
      try {
        final posts = await remoteDataSource.searchPosts(params);
        return Right(posts);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    } else {
      return Left(NoInternetFailure());
    }
  }

  @override
  Future<Either<Failure, List<PostEntity>>> getBookmarkedPosts(ListIdParams params) async {
    if (await networkInfo.isConnected) {
      try {
        final posts = await remoteDataSource.getPostsByIds(params);
        return Right(posts);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    } else {
      return Left(NoInternetFailure());
    }
  }

  @override
  Future<Either<Failure, List<PostEntity>>> getPostsByUserId(GetPostsByUserIdParams params) async {
    if (await networkInfo.isConnected) {
      try {
        final posts = await remoteDataSource.getPostsByUserId(params);
        return Right(posts);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    } else {
      return Left(NoInternetFailure());
    }
  }
}


Path: lib\features\post\domain\entities\post_entity.dart
Code:
import 'package:equatable/equatable.dart';

class PostEntity extends Equatable {
  final String id;
  final String userId;
  final String title;
  final String body;
  final String imageUrl;
  final DateTime createdAt;
  final DateTime updatedAt;

  const PostEntity({
    required this.id,
    required this.userId,
    required this.title,
    required this.body,
    required this.imageUrl,
    required this.createdAt,
    required this.updatedAt,
  });

  @override
  List<Object?> get props => [id, userId, title, body, imageUrl, createdAt, updatedAt];

  PostEntity copyWith({
    String? id,
    String? userId,
    String? title,
    String? body,
    String? imageUrl,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return PostEntity(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      title: title ?? this.title,
      body: body ?? this.body,
      imageUrl: imageUrl ?? this.imageUrl,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}


Path: lib\features\post\domain\repositories\post_repository.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/post_entity.dart';
import '../usecases/create_post_usecase.dart';
import '../usecases/get_posts_by_user_id_usecase.dart';
import '../usecases/search_posts_usecase.dart';

abstract class PostRepository {
  Future<Either<Failure, List<PostEntity>>> getAllPosts(PaginationParams params);
  Future<Either<Failure, List<PostEntity>>> getPostsByUserId(GetPostsByUserIdParams params);
  Future<Either<Failure, PostEntity>> getPostById(IdParams params);
  Future<Either<Failure, PostEntity>> createPost(CreatePostParams params);
  Future<Either<Failure, PostEntity>> updatePost(PostEntity post);
  Future<Either<Failure, void>> deletePost(PostEntity post);
  Future<Either<Failure, List<PostEntity>>> searchPosts(PaginationSearchPostParams params);
  Future<Either<Failure, List<PostEntity>>> getBookmarkedPosts(ListIdParams params);
}


Path: lib\features\post\domain\usecases\create_post_usecase.dart
Code:
import 'package:dartz/dartz.dart';
import 'package:equatable/equatable.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/post_entity.dart';
import '../repositories/post_repository.dart';

class CreatePostUseCase implements UseCase<PostEntity, CreatePostParams> {
  final PostRepository repository;

  CreatePostUseCase(this.repository);

  @override
  Future<Either<Failure, PostEntity>> call(CreatePostParams params) async {
    return await repository.createPost(params);
  }
}

class CreatePostParams extends Equatable {
  final String userId;
  final String title;
  final String body;

  const CreatePostParams({required this.userId, required this.title, required this.body});

  @override
  List<Object?> get props => [userId, title, body];
}


Path: lib\features\post\domain\usecases\delete_post_usecase.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/post_entity.dart';
import '../repositories/post_repository.dart';

class DeletePostUseCase implements UseCase<void, PostEntity> {
  final PostRepository repository;
  DeletePostUseCase(this.repository);

  @override
  Future<Either<Failure, void>> call(PostEntity postEntity) async {
    return await repository.deletePost(postEntity);
  }
}


Path: lib\features\post\domain\usecases\get_all_posts_usecase.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/post_entity.dart';
import '../repositories/post_repository.dart';

class GetAllPostsUseCase implements UseCase<List<PostEntity>, PaginationParams> {
  final PostRepository repository;

  GetAllPostsUseCase(this.repository);

  @override
  Future<Either<Failure, List<PostEntity>>> call(PaginationParams params) async {
    return await repository.getAllPosts(params);
  }
}


Path: lib\features\post\domain\usecases\get_bookmarked_posts_usecase.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/post_entity.dart';
import '../repositories/post_repository.dart';

class GetBookmarkedPostsUseCase implements UseCase<List<PostEntity>, ListIdParams> {
  final PostRepository repository;

  GetBookmarkedPostsUseCase(this.repository);

  @override
  Future<Either<Failure, List<PostEntity>>> call(ListIdParams params) async {
    return await repository.getBookmarkedPosts(params);
  }
}


Path: lib\features\post\domain\usecases\get_posts_by_user_id_usecase.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/post_entity.dart';
import '../repositories/post_repository.dart';

class GetPostsByUserIdUseCase implements UseCase<List<PostEntity>, GetPostsByUserIdParams> {
  final PostRepository repository;

  GetPostsByUserIdUseCase(this.repository);

  @override
  Future<Either<Failure, List<PostEntity>>> call(GetPostsByUserIdParams params) async {
    return await repository.getPostsByUserId(params);
  }
}

class GetPostsByUserIdParams extends PaginationParams {
  final String userId;
  const GetPostsByUserIdParams({
    required this.userId,
    required super.page,
    required super.limit,
    super.order,
  });
}


Path: lib\features\post\domain\usecases\get_post_by_id_usecase.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/post_entity.dart';
import '../repositories/post_repository.dart';

class GetPostByIdUseCase implements UseCase<PostEntity, IdParams> {
  final PostRepository repository;
  GetPostByIdUseCase(this.repository);

  @override
  Future<Either<Failure, PostEntity>> call(IdParams params) async {
    return await repository.getPostById(params);
  }
}


Path: lib\features\post\domain\usecases\search_posts_usecase.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/post_entity.dart';
import '../repositories/post_repository.dart';

class SearchPostsUseCase implements UseCase<List<PostEntity>, PaginationSearchPostParams> {
  final PostRepository repository;

  SearchPostsUseCase(this.repository);

  @override
  Future<Either<Failure, List<PostEntity>>> call(PaginationSearchPostParams params) async {
    return await repository.searchPosts(params);
  }
}

class PaginationSearchPostParams extends PaginationParams {
  final String search;

  const PaginationSearchPostParams({
    required super.page,
    required super.limit,
    required this.search,
    super.order,
  });

  @override
  List<Object?> get props => [page, limit, search];
}


Path: lib\features\post\domain\usecases\update_post_usecase.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/post_entity.dart';
import '../repositories/post_repository.dart';

class UpdatePostUseCase implements UseCase<PostEntity, PostEntity> {
  final PostRepository repository;

  UpdatePostUseCase(this.repository);

  @override
  Future<Either<Failure, PostEntity>> call(PostEntity params) async {
    return await repository.updatePost(params);
  }
}


Path: lib\features\post\presentation\blocs\post_bloc.dart
Code:
import 'package:equatable/equatable.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../app/logs.dart';
import '../../../../core/constants/pagination.dart';
import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/params.dart';
import '../../domain/entities/post_entity.dart';
import '../../domain/usecases/create_post_usecase.dart';
import '../../domain/usecases/delete_post_usecase.dart';
import '../../domain/usecases/get_all_posts_usecase.dart';
import '../../domain/usecases/get_bookmarked_posts_usecase.dart';
import '../../domain/usecases/get_post_by_id_usecase.dart';
import '../../domain/usecases/get_posts_by_user_id_usecase.dart';
import '../../domain/usecases/search_posts_usecase.dart';
import '../../domain/usecases/update_post_usecase.dart';

part 'post_event.dart';
part 'post_state.dart';

class PostBloc extends Bloc<PostEvent, PostState> {
  final GetAllPostsUseCase getAllPosts;
  final GetPostByIdUseCase getPostById;
  final CreatePostUseCase createPost;
  final UpdatePostUseCase updatePost;
  final DeletePostUseCase deletePost;
  final SearchPostsUseCase searchPosts;
  final GetPostsByUserIdUseCase getPostsByUserIdUseCase;
  final GetBookmarkedPostsUseCase getBookmarkedPosts;
  final LogService logService;
  PostBloc({
    required this.getAllPosts,
    required this.getPostById,
    required this.createPost,
    required this.updatePost,
    required this.deletePost,
    required this.searchPosts,
    required this.getBookmarkedPosts,
    required this.getPostsByUserIdUseCase,
    required this.logService,
  }) : super(PostInitial()) {
    on<GetAllPostsEvent>(_onGetAllPosts);
    on<GetPostByIdEvent>(_onGetPostById);
    on<CreatePostEvent>(_onCreatePost);
    on<UpdatePostEvent>(_onUpdatePost);
    on<DeletePostEvent>(_onDeletePost);
    on<SearchPostsEvent>(_onSearchPosts);
    on<GetBookmarkedPostsEvent>(_onGetBookmarkedPosts);
    on<GetPostsByUserIdEvent>(_onGetPostsByUserId);
  }

  final _allPostPS = PaginationStorage();

  Future<void> _onGetAllPosts(GetAllPostsEvent event, Emitter<PostState> emit) async {
    final results = await getAllPosts(
      PaginationParams(page: _allPostPS.currentPage, limit: _allPostPS.limit),
    );

    results.fold(
      (failure) {
        logService.e(
          '$failure occur at _onGetAllPosts(GetAllPostsEvent event, Emitter<PostState> emit)',
        );
        emit(PostError(failure: failure));
      },
      (posts) {
        _handleGetListPosts(emit: emit, posts: posts, ps: _allPostPS);
      },
    );
  }

  PaginationStorage _userPostPS = PaginationStorage();
  String _currentUserIdPost = '';

  Future<void> _onGetPostsByUserId(GetPostsByUserIdEvent event, Emitter<PostState> emit) async {
    if (event.userId != _currentUserIdPost) _userPostPS = PaginationStorage();
    _currentUserIdPost = event.userId;

    final results = await getPostsByUserIdUseCase(
      GetPostsByUserIdParams(
        userId: event.userId,
        page: _userPostPS.currentPage,
        limit: _userPostPS.limit,
      ),
    );

    results.fold(
      (failure) {
        logService.e(
          '$failure occur at _onGetAllPosts(GetAllPostsEvent event, Emitter<PostState> emit)',
        );
        emit(PostError(failure: failure));
      },
      (posts) {
        _handleGetListPosts(emit: emit, posts: posts, ps: _userPostPS);
      },
    );
  }

  void _handleGetListPosts({
    required List<PostEntity> posts,
    required PaginationStorage ps,
    required Emitter<PostState> emit,
  }) {
    if (posts.isEmpty) {
      ps.hasMore = false;
      if (state is PostsLoaded) {
        emit((state as PostsLoaded).copyWith(hasMore: false));
        return;
      } else {
        emit(PostsLoaded(posts: [], hasMore: false));
        return;
      }
    }

    if (ps.currentPage == 1 && posts.length < ps.limit) ps.hasMore = false;
    ps.currentPage++;

    if (state is PostsLoaded) {
      emit((state as PostsLoaded).copyWith(posts: posts, hasMore: ps.hasMore));
      return;
    } else {
      emit(PostsLoaded(posts: posts, hasMore: ps.hasMore));
      return;
    }
  }

  PaginationStorage _searchPostsPS = PaginationStorage();
  String _currentSearchQuery = '';

  Future<void> _onSearchPosts(SearchPostsEvent event, Emitter<PostState> emit) async {
    if (event.query != _currentSearchQuery) {
      _searchPostsPS = PaginationStorage();
      emit(PostsLoaded(posts: [], hasMore: true));
    }
    _currentSearchQuery = event.query;

    final results = await searchPosts(
      PaginationSearchPostParams(
        page: _searchPostsPS.currentPage,
        limit: _searchPostsPS.limit,
        search: event.query,
      ),
    );

    results.fold(
      (failure) {
        logService.w(
          '$failure occur at _onGetAllPosts(GetAllPostsEvent event, Emitter<PostState> emit)',
        );
        return emit(PostError(failure: failure));
      },
      (posts) {
        _handleGetListPosts(emit: emit, posts: posts, ps: _searchPostsPS);
      },
    );
  }

  Future<void> _onGetPostById(GetPostByIdEvent event, Emitter<PostState> emit) async {
    emit(PostLoading());
    final result = await getPostById(IdParams(id: event.id));

    emit(
      result.fold((failure) {
        logService.w(
          '$failure occur at _onGetAllPosts(GetAllPostsEvent event, Emitter<PostState> emit)',
        );
        return PostError(failure: failure);
      }, (post) => PostLoaded(post: post)),
    );
  }

  Future<void> _onCreatePost(CreatePostEvent event, Emitter<PostState> emit) async {
    if (state is PostsLoaded) {
      final result = await createPost(event.params);

      result.fold(
        (failure) {
          logService.w(
            '$failure occur at _onCreatePost(CreatePostEvent event, Emitter<PostState> emit)',
          );
          emit(PostError(failure: failure));
        },
        (post) {
          if ((state as PostsLoaded).posts.isEmpty) {
            emit(PostsLoaded(hasMore: false, posts: [post]));
            return;
          } else {
            emit((state as PostsLoaded).copyWith(posts: [post], isInsert: true));
            return;
          }
        },
      );
    }
  }

  Future<void> _onUpdatePost(UpdatePostEvent event, Emitter<PostState> emit) async {
    final currentState = state;
    if (currentState is PostsLoaded) {
      final result = await updatePost(event.post);

      result.fold(
        (failure) {
          logService.w(
            '$failure occur at _onGetAllPosts(GetAllPostsEvent event, Emitter<PostState> emit)',
          );
          emit(PostError(failure: failure));
        },
        (updatedPost) {
          final updatedPosts =
              currentState.posts.map((post) {
                return post.id == updatedPost.id ? updatedPost : post;
              }).toList();
          emit(PostsLoaded(posts: updatedPosts, hasMore: currentState.hasMore));
        },
      );
    }
  }

  Future<void> _onDeletePost(DeletePostEvent event, Emitter<PostState> emit) async {
    final currentState = state;
    if (currentState is PostsLoaded) {
      final result = await deletePost(event.post);

      result.fold(
        (failure) {
          logService.w(
            '$failure occur at _onGetAllPosts(GetAllPostsEvent event, Emitter<PostState> emit)',
          );
          emit(PostError(failure: failure));
        },
        (_) {
          final updatedPosts =
              currentState.posts.where((post) => post.id != event.post.id).toList();
          emit(PostsLoaded(posts: updatedPosts, hasMore: currentState.hasMore));
        },
      );
    }
  }

  Future<void> _onGetBookmarkedPosts(GetBookmarkedPostsEvent event, Emitter<PostState> emit) async {
    final results = await getBookmarkedPosts(ListIdParams(ids: event.bookmarksId));
    emit(
      results.fold((failure) {
        logService.w(
          '$failure occur at _onGetAllPosts(GetAllPostsEvent event, Emitter<PostState> emit)',
        );
        return PostError(failure: failure);
      }, (posts) => PostsLoaded(posts: posts, hasMore: false)),
    );
  }
}


Path: lib\features\post\presentation\blocs\post_event.dart
Code:
part of 'post_bloc.dart';

abstract class PostEvent extends Equatable {
  const PostEvent();

  @override
  List<Object> get props => [];
}

class GetAllPostsEvent extends PostEvent {}

class GetPostsByUserIdEvent extends PostEvent {
  final String userId;
  const GetPostsByUserIdEvent({required this.userId});
  @override
  List<Object> get props => [userId];
}

class GetPostByIdEvent extends PostEvent {
  final String id;
  const GetPostByIdEvent({required this.id});
  @override
  List<Object> get props => [id];
}

class CreatePostEvent extends PostEvent {
  final CreatePostParams params;
  const CreatePostEvent({required this.params});
  @override
  List<Object> get props => [params];
}

class UpdatePostEvent extends PostEvent {
  final PostEntity post;
  const UpdatePostEvent({required this.post});
  @override
  List<Object> get props => [post];
}

class DeletePostEvent extends PostEvent {
  final PostEntity post;
  const DeletePostEvent({required this.post});
  @override
  List<Object> get props => [post];
}

class SearchPostsEvent extends PostEvent {
  final String query;
  const SearchPostsEvent({required this.query});
  @override
  List<Object> get props => [query];
}

class GetBookmarkedPostsEvent extends PostEvent {
  final List<String> bookmarksId;
  const GetBookmarkedPostsEvent({required this.bookmarksId});

  @override
  List<Object> get props => [bookmarksId];
}

//


Path: lib\features\post\presentation\blocs\post_state.dart
Code:
part of 'post_bloc.dart';

abstract class PostState extends Equatable {
  const PostState();

  @override
  List<Object> get props => [];
}

class PostInitial extends PostState {}

class PostLoading extends PostState {}

class PostsLoaded extends PostState {
  final List<PostEntity> posts;
  final bool hasMore;
  const PostsLoaded({required this.posts, required this.hasMore});
  @override
  List<Object> get props => [posts, hasMore];

  PostsLoaded copyWith({List<PostEntity>? posts, bool? hasMore, bool isInsert = false}) {
    return PostsLoaded(
      posts:
          posts != null
              ? isInsert
                  ? [...posts, ...this.posts]
                  : [...this.posts, ...posts]
              : this.posts,
      hasMore: hasMore ?? this.hasMore,
    );
  }
}

class PostLoaded extends PostState {
  final PostEntity post;
  const PostLoaded({required this.post});
  @override
  List<Object> get props => [post];
}

class PostError extends PostState {
  final Failure failure;
  const PostError({required this.failure});
  @override
  List<Object> get props => [failure];
}


Path: lib\features\post\presentation\pages\bookmarked_posts_page.dart
Code:
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../app/locale.dart';
import '../../../../core/widgets/layout.dart';
import '../../../../injection_container.dart';
import '../../../auth/presentation/blocs/auth_bloc.dart';
import '../../../user/presentation/blocs/user_bloc.dart';
import '../blocs/post_bloc.dart';
import '../widgets/list_post.dart';

class BookmarkedPostsPage extends StatefulWidget {
  const BookmarkedPostsPage({super.key});

  @override
  State<BookmarkedPostsPage> createState() => _BookmarkedPostsPageState();
}

class _BookmarkedPostsPageState extends State<BookmarkedPostsPage> {
  late PostBloc _postBloc;
  late UserBloc _userBloc;

  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    _postBloc = sl<PostBloc>();
    _userBloc =
        sl<UserBloc>()..add(GetUserByIdEvent(id: (sl<AuthBloc>().state as AuthLoaded).auth.id));

    _loadBookmarkedPost();
  }

  @override
  void dispose() {
    _postBloc.close();
    _userBloc.close();
    super.dispose();
  }

  void _loadBookmarkedPost() {
    if (_userBloc.state is UserLoaded) {
      final bookmarkPostIds = (_userBloc.state as UserLoaded).user.bookmarksId;
      _postBloc.add(GetBookmarkedPostsEvent(bookmarksId: bookmarkPostIds));
    }
  }

  @override
  Widget build(BuildContext context) {
    return MultiBlocProvider(
      providers: [
        BlocProvider<PostBloc>(create: (_) => _postBloc),
        BlocProvider<UserBloc>(create: (_) => _userBloc),
      ],
      child: Scaffold(
        appBar: AppBar(
          title: Text(context.tr(I18nKeys.bookmarkedPosts)),
          centerTitle: true,
        ), //ADD Translate
        body: safeWrapContainer(
          context,
          _scrollController,
          hasBottomBar: false,
          BlocBuilder<UserBloc, UserState>(
            builder: (_, userState) {
              if (userState is UserInitial || userState is UserLoading) {
                return const Center(child: CircularProgressIndicator());
              } else if (userState is UserError) {
                return Center(child: Text('Error (Post): ${userState.failure.message}'));
              } else if (userState is! UserLoaded) {
                return Center(child: Text('Unknown User State: $userState'));
              }
              _loadBookmarkedPost();

              return BlocBuilder<PostBloc, PostState>(
                builder: (_, postState) {
                  if (postState is PostInitial) {
                    return const Center(child: CircularProgressIndicator());
                  } else if (postState is PostError) {
                    return Center(child: Text('Error (Post): ${postState.failure.message}'));
                  } else if (postState is PostsLoaded) {
                    final bookmarkedPosts = postState.posts;
                    return bookmarkedPosts.isEmpty
                        ? Center(child: Text(context.tr(I18nKeys.noBookmarkedPosts)))
                        : ListPostWidget(bookmarkedPosts, postState.hasMore);
                  } else {
                    return Center(child: Text('Unknown Post State: $postState'));
                  }
                },
              );
            },
          ),
        ),
      ),
    );
  }
}


Path: lib\features\post\presentation\pages\post_detail_page.dart
Code:
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../app/locale.dart';
import '../../../../core/extensions/build_content_extensions.dart';
import '../../../../core/extensions/scroll_controller.dart';
import '../../../../core/extensions/widget_extensions.dart';
import '../../../../core/widgets/has_more_incaditor.dart';
import '../../../../core/widgets/layout.dart';
import '../../../../core/widgets/post_item.dart';
import '../../../../injection_container.dart';
import '../../../auth/presentation/blocs/auth_bloc.dart';
import '../../../comment/domain/entities/comment_entity.dart';
import '../../../comment/presentation/blocs/comment_bloc.dart';
import '../../../user/presentation/blocs/user_bloc.dart';
import '../blocs/post_bloc.dart';
import '../widgets/comment_item.dart';

class PostDetailPage extends StatefulWidget {
  final String postId;

  const PostDetailPage({super.key, required this.postId});

  @override
  State<PostDetailPage> createState() => _PostDetailPageState();
}

class _PostDetailPageState extends State<PostDetailPage> {
  final TextEditingController _comment = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  late PostBloc _postBloc;
  late CommentBloc _commentBloc;
  late UserBloc _userBloc;
  bool _loadingComments = false;

  @override
  void initState() {
    super.initState();
    _postBloc = sl<PostBloc>()..add(GetPostByIdEvent(id: widget.postId));
    _commentBloc = sl<CommentBloc>()..add(GetCommentsEvent(postId: widget.postId));
    _userBloc =
        sl<UserBloc>()..add(GetUserByIdEvent(id: (sl<AuthBloc>().state as AuthLoaded).auth.id));
    _scrollController.addListener(_onScroll);
    _bookmarkStatus();
  }

  @override
  void dispose() {
    _comment.dispose();
    _scrollController.dispose();
    _postBloc.close();
    _commentBloc.close();
    _userBloc.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return MultiBlocProvider(
      providers: [
        BlocProvider<PostBloc>(create: (_) => _postBloc),
        BlocProvider<CommentBloc>(create: (_) => _commentBloc),
        BlocProvider<UserBloc>(create: (_) => _userBloc),
      ],
      child: Scaffold(
        appBar: AppBar(title: Text(context.tr(I18nKeys.postDetail)), centerTitle: true),
        body: safeWrapContainer(
          context,
          _scrollController,
          border: Border.all(color: context.colorScheme.outline),
          BlocBuilder<PostBloc, PostState>(
            builder: (_, postState) {
              if (postState is PostInitial || postState is PostLoading) {
                return const Center(child: CircularProgressIndicator());
              } else if (postState is PostError) {
                return Center(child: Text('Error: ${postState.failure.message}'));
              } else if (postState is PostLoaded) {
                final post = postState.post;
                return Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    // PostItem(post: post, isDetail: true, key: post.key),
                    PostItem(post: post, isDetail: true),

                    BlocBuilder<CommentBloc, CommentState>(
                      builder: (_, commentState) {
                        if (commentState is CommentInitial) {
                          return const Center(child: CircularProgressIndicator());
                        } else if (commentState is CommentError) {
                          return Center(child: Text('Error: ${commentState.failure.message}'));
                        } else if (commentState is CommentsLoaded) {
                          _loadingComments = false;

                          return _buildCommentsSection(commentState.comments, commentState.hasMore);
                        }
                        return SizedBox.shrink();
                      },
                    ),
                  ],
                );
              } else {
                return const SizedBox.shrink();
              }
            },
          ),
        ),
        floatingActionButton: FloatingActionButton(
          onPressed: _bookmarkPost,
          child: BlocBuilder<UserBloc, UserState>(
            builder: (context, state) {
              if (state is UserLoaded && _bookmarkStatus()) {
                return Icon(Icons.bookmark);
              }
              return Icon(Icons.bookmark_outline);
            },
          ),
        ),
      ),
    );
  }

  Widget _buildCommentsSection(List<CommentEntity> listComment, bool hasMore) {
    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            context.tr(I18nKeys.comments),
            style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
          ),
          16.sbH(),
          BlocBuilder<AuthBloc, AuthState>(
            builder: (context, state) {
              if (state is AuthLoaded) {
                final currentUser = state.auth;
                return Row(
                  children: [
                    Expanded(
                      child: TextField(
                        controller: _comment,
                        maxLines: 4,
                        decoration: InputDecoration(
                          hintText: context.tr(I18nKeys.addAComment),
                          border: OutlineInputBorder(),
                        ),
                      ),
                    ),
                    // Pass the user ID to the _addComment function.
                    IconButton(
                      icon: const Icon(Icons.send),
                      onPressed: () => _addComment(currentUser.id),
                    ),
                  ],
                );
              } else {
                return Center(child: Text(context.tr(I18nKeys.loginToAddComments)));
              }
            },
          ),
          16.sbH(),
          ListView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            itemCount: listComment.length + 1,
            itemBuilder: (context, index) {
              if (index < listComment.length) {
                final comment = listComment[index];
                // Check if the current user is the author of the comment
                return BlocBuilder<AuthBloc, AuthState>(
                  builder: (_, authState) {
                    bool isMyComment = false;
                    if (authState is AuthLoaded) {
                      isMyComment = comment.user.id == authState.auth.id;
                    }

                    return CommentItem(
                      key: ValueKey('comment-${comment.id}'),
                      comment: comment,
                      isMyComment: isMyComment,
                      onEdit: () => _showEditDialog(comment),
                      onDelete: () => _showDeleteDialog(comment),
                    );
                  },
                );
              } else {
                return hasMoreWidget(context, hasMore);
              }
            },
          ),
        ],
      ),
    );
  }

  void _onScroll() {
    if (_loadingComments) return;

    if (_scrollController.isBottom) {
      _loadingComments = true;
      _commentBloc.add(GetCommentsEvent(postId: widget.postId));
    }
  }

  void _addComment(String userId) {
    if (_comment.text.trim().isNotEmpty) {
      _commentBloc.add(AddCommentEvent(postId: widget.postId, userId: userId, body: _comment.text));
      _comment.clear();
    }
  }

  void _showEditDialog(CommentEntity comment) {
    String editedComment = comment.body;

    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(context.tr(I18nKeys.editComment)),
          content: SizedBox(
            width: 500,
            child: TextFormField(
              initialValue: editedComment,
              maxLines: 4,
              decoration: InputDecoration(hintText: context.tr(I18nKeys.updateYourComment)),
              onChanged: (value) {
                editedComment = value;
              },
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: Text(context.tr(I18nKeys.cancel)),
            ),
            TextButton(
              onPressed: () {
                _commentBloc.add(
                  UpdateCommentEvent(comment: comment.copyWith(body: editedComment)),
                );
                Navigator.of(context).pop();
              },
              child: Text(context.tr(I18nKeys.updateComment)),
            ),
          ],
        );
      },
    );
  }

  void _showDeleteDialog(CommentEntity comment) {
    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(context.tr(I18nKeys.deleteComment)),
          content: SizedBox(width: 500, child: Text(context.tr(I18nKeys.deleteCommentConfirm))),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: Text(context.tr(I18nKeys.cancel)),
            ),
            TextButton(
              onPressed: () {
                _commentBloc.add(DeleteCommentEvent(comment: comment));
                Navigator.of(context).pop();
              },
              child: Text(context.tr(I18nKeys.deleteCommentConfirmAction)),
            ),
          ],
        );
      },
    );
  }

  void _bookmarkPost() {
    if (_userBloc.state is UserLoaded) {
      final user = (_userBloc.state as UserLoaded).user;
      _userBloc.add(
        BookmarkPostEvent(
          userId: user.id,
          postId: widget.postId,
          bookmarkedPostIds: user.bookmarksId,
        ),
      );
    }
  }

  bool _bookmarkStatus() {
    if (_userBloc.state is UserLoaded) {
      return (_userBloc.state as UserLoaded).user.bookmarksId.contains(widget.postId);
    }
    return false;
  }
}


Path: lib\features\post\presentation\pages\post_list_page.dart
Code:
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';

import '../../../../app/locale.dart';
import '../../../../app/routes.dart';
import '../../../../core/extensions/scroll_controller.dart';
import '../../../../core/widgets/widgets.dart';
import '../../../../injection_container.dart';
import '../blocs/post_bloc.dart';
import '../widgets/list_post.dart';

class PostListPage extends StatefulWidget {
  const PostListPage({super.key});

  @override
  State<PostListPage> createState() => _PostListPageState();
}

class _PostListPageState extends State<PostListPage> {
  final ScrollController _scrollController = ScrollController();
  late PostBloc _bloc;
  bool _loadingPosts = false;

  @override
  void initState() {
    super.initState();
    _bloc = sl<PostBloc>()..add(GetAllPostsEvent());
    _scrollController.addListener(_onScroll);
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _bloc.close();
    super.dispose();
  }

  void _onScroll() {
    if (_loadingPosts) return;

    if (_scrollController.isBottom) {
      _loadingPosts = true;
      _bloc.add(GetAllPostsEvent());
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(context.tr(I18nKeys.posts)),
        centerTitle: true,
        actions: [
          IconButton(
            icon: const Icon(Icons.bookmark),
            onPressed: () {
              context.push(Paths.bookmarkedPost);
            },
          ),
          const SizedBox(width: 10),
        ],
      ),
      body: safeWrapContainer(
        context,
        _scrollController,
        BlocProvider<PostBloc>(
          create: (_) => _bloc,
          child: BlocBuilder<PostBloc, PostState>(
            builder: (_, state) {
              if (state is PostInitial) {
                return const Center(child: CircularProgressIndicator());
              } else if (state is PostError) {
                return Center(child: Text(state.failure.message.toString()));
              } else if (state is PostsLoaded) {
                _loadingPosts = false;
                return ListPostWidget(state.posts, state.hasMore);
              }
              return Center(child: Text('Unknown State: $state'));
            },
          ),
        ),
      ),
    );
  }
}


Path: lib\features\post\presentation\pages\search_page.dart
Code:
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../app/locale.dart';
import '../../../../core/extensions/scroll_controller.dart';
import '../../../../core/widgets/widgets.dart';
import '../../../../injection_container.dart';
import '../blocs/post_bloc.dart';
import '../widgets/list_post.dart';

class SearchPage extends StatefulWidget {
  const SearchPage({super.key});

  @override
  SearchPageState createState() => SearchPageState();
}

class SearchPageState extends State<SearchPage> {
  final TextEditingController _search = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  late PostBloc _bloc;
  bool _loadingPost = false;

  @override
  void initState() {
    _bloc = sl<PostBloc>();
    _scrollController.addListener(_onScroll);
    super.initState();
  }

  @override
  void dispose() {
    _search.dispose();
    _bloc.close();
    super.dispose();
  }

  void _onScroll() {
    if (_loadingPost) return;

    if (_scrollController.isBottom && _search.text.isNotEmpty) {
      _loadingPost = true;
      _bloc.add(SearchPostsEvent(query: _search.text));
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text(context.tr(I18nKeys.search)), centerTitle: true),
      body: safeWrapContainer(
        context,
        _scrollController,
        BlocProvider<PostBloc>(
          create: (_) => _bloc,
          child: Column(
            children: [
              _buildSearchField(_bloc),
              BlocBuilder<PostBloc, PostState>(
                builder: (context, state) {
                  if (state is PostInitial) {
                    return Center(child: Text(context.tr(I18nKeys.enterSearchTerms)));
                  } else if (state is PostError) {
                    return Center(child: Text(state.failure.message.toString()));
                  } else if (state is PostsLoaded) {
                    _loadingPost = false;
                    return ListPostWidget(state.posts, state.hasMore);
                  }
                  return Center(child: Text('Unknown State: $state'));
                },
              ),
            ],
          ),
        ),
      ),
    );
  }

  Padding _buildSearchField(PostBloc bloc) {
    return Padding(
      padding: const EdgeInsets.all(8.0),
      child: TextField(
        controller: _search,
        decoration: InputDecoration(
          labelText: context.tr(I18nKeys.search),
          suffixIcon: IconButton(icon: const Icon(Icons.clear), onPressed: () => _search.clear()),
          prefixIcon: IconButton(
            icon: const Icon(Icons.search),
            // Perform the search
            onPressed: () => bloc.add(SearchPostsEvent(query: _search.text)),
          ),
        ),
        onSubmitted: (value) => bloc.add(SearchPostsEvent(query: value)),
      ),
    );
  }
}


Path: lib\features\post\presentation\widgets\comment_item.dart
Code:
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';

import '../../../comment/domain/entities/comment_entity.dart';

class CommentItem extends StatelessWidget {
  const CommentItem({
    super.key,
    required this.comment,
    required this.isMyComment,
    this.onEdit,
    this.onDelete,
  });

  final CommentEntity comment;
  final bool isMyComment;
  final Function()? onEdit;
  final Function()? onDelete;

  @override
  Widget build(BuildContext context) {
    return ListTile(
      leading: CircleAvatar(
        radius: 30,
        backgroundImage: CachedNetworkImageProvider(comment.user.avatar),
      ),
      title: Text(comment.user.userName),
      subtitle: Text(comment.body),
      trailing:
          isMyComment
              ? Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  IconButton(icon: const Icon(Icons.edit), onPressed: onEdit),
                  IconButton(icon: const Icon(Icons.delete), onPressed: onDelete),
                ],
              )
              : SizedBox.shrink(),
    );
  }
}


Path: lib\features\post\presentation\widgets\list_post.dart
Code:
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

import '../../../../app/routes.dart';
import '../../../../core/extensions/widget_extensions.dart';
import '../../../../core/widgets/has_more_incaditor.dart';
import '../../../../core/widgets/post_item.dart';
import '../../domain/entities/post_entity.dart';

class ListPostWidget extends StatelessWidget {
  const ListPostWidget(
    this.posts,
    this.hasMore, {
    super.key,
    this.isEditable = false,
    this.onEditPostCallback,
    this.onDeletePostCallback,
  });

  final List<PostEntity> posts;
  final bool hasMore;
  final bool isEditable;
  final Function(PostEntity)? onEditPostCallback;
  final Function(PostEntity)? onDeletePostCallback;

  @override
  Widget build(BuildContext context) {
    return ListView.separated(
      separatorBuilder: (_, _) => 16.sbH(),
      shrinkWrap: true,
      physics: NeverScrollableScrollPhysics(),
      itemCount: posts.length + 1,
      itemBuilder: (context, index) {
        if (index == posts.length) {
          return hasMoreWidget(context, hasMore);
        }
        final post = posts[index];
        return PostItem(
          key: ValueKey('post-${post.id}'),
          post: post,
          callback: () => context.push('${Paths.postDetail}/${post.id}'),
          isEditable: isEditable,
          onDeletePostCallback: onDeletePostCallback,
          onEditPostCallback: onEditPostCallback,
        );
      },
    );
  }
}


Path: lib\features\presentation\home\pages\home_page.dart
Code:
import 'package:flutter/material.dart';

import '../../../../app/locale.dart';
import '../../../post/presentation/pages/post_list_page.dart';
import '../../../post/presentation/pages/search_page.dart';
import '../../../user/presentation/pages/users_page.dart';
import '../../settings/pages/settings_page.dart';

class HomePage extends StatefulWidget {
  const HomePage({super.key, this.initialTab = 0});
  final int initialTab;

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  late int _selectedIndex;

  List<Widget> _pages = [];

  @override
  void initState() {
    super.initState();
    _selectedIndex = widget.initialTab;
    _pages = [PostListPage(), SearchPage(), UsersPage(), SettingsPage()];
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: IndexedStack(index: _selectedIndex, children: _pages),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _selectedIndex,
        onTap: (index) {
          setState(() => _selectedIndex = index);
        },
        items: [
          BottomNavigationBarItem(icon: Icon(Icons.home), label: context.tr(I18nKeys.home)),
          BottomNavigationBarItem(icon: Icon(Icons.search), label: context.tr(I18nKeys.search)),
          BottomNavigationBarItem(icon: Icon(Icons.people), label: context.tr(I18nKeys.users)),
          BottomNavigationBarItem(icon: Icon(Icons.settings), label: context.tr(I18nKeys.settings)),
        ],
        type: BottomNavigationBarType.fixed,
      ),
    );
  }
}


Path: lib\features\presentation\settings\pages\settings_page.dart
Code:
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';

import '../../../../app/cubits/locale_cubit.dart';
import '../../../../app/cubits/theme_cubit.dart';
import '../../../../app/locale.dart';
import '../../../../app/routes.dart';
import '../../../../configs/locale_config.dart';
import '../../../../injection_container.dart';
import '../../../auth/presentation/blocs/auth_bloc.dart';

class SettingsPage extends StatefulWidget {
  const SettingsPage({super.key});

  @override
  State<SettingsPage> createState() => _SettingsPageState();
}

class _SettingsPageState extends State<SettingsPage> {
  final _newPassword = TextEditingController();

  void _showChangePasswordDialog() {
    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(context.tr(I18nKeys.changePassword)),
          content: SizedBox(
            width: 500,
            child: TextFormField(
              controller: _newPassword,
              obscureText: true,
              decoration: InputDecoration(hintText: context.tr(I18nKeys.enterNewPassword)),
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: Text(context.tr(I18nKeys.cancel)),
            ),
            TextButton(
              onPressed: () {
                final authBloc = sl<AuthBloc>();
                if (_newPassword.text.isNotEmpty && authBloc.state is AuthLoaded) {
                  sl<AuthBloc>().add(
                    UpdatePasswordEvent(
                      newPassword: _newPassword.text,
                      userId: (authBloc.state as AuthLoaded).auth.id,
                    ),
                  );
                }
                Navigator.of(context).pop();
                context.pushReplacement(Paths.login);
              },
              child: Text(context.tr(I18nKeys.changePasswordAction)),
            ),
          ],
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text(context.tr(I18nKeys.settings))),
      body: BlocBuilder<AuthBloc, AuthState>(
        builder: (context, authState) {
          return ListView(
            children: [
              if (authState is AuthLoaded) ...[
                ListTile(
                  leading: Icon(Icons.account_circle_outlined),
                  title: Text(context.tr(I18nKeys.userProfile)),
                  trailing: const Icon(Icons.arrow_forward_ios),
                  onTap: () {
                    context.push('${Paths.userProfile}/${authState.auth.id}');
                  },
                ),
                const Divider(),
              ],
              _buildThemeTile(context),
              const Divider(),
              _buildLanguageTile(context),
              const Divider(),
              ListTile(
                title: Text(context.tr(I18nKeys.changePassword)),
                leading: const Icon(Icons.key),
                onTap: _showChangePasswordDialog,
              ),
              const Divider(),
              ListTile(
                title: Text(context.tr(I18nKeys.logout)),
                leading: const Icon(Icons.logout),
                onTap: () {
                  context.read<AuthBloc>().add(LogoutEvent());
                  context.pushReplacement(Paths.login);
                },
              ),
            ],
          );
        },
      ),
    );
  }

  Widget _buildThemeTile(BuildContext context) {
    final options = [ThemeCubit.lightThemeKey, ThemeCubit.darkThemeKey, ThemeCubit.customThemeKey];

    return BlocBuilder<ThemeCubit, ThemeData>(
      builder: (context, theme) {
        final selectedTheme = ThemeCubit.themeToString(theme);
        return _buildOptionTile(
          title: context.tr(I18nKeys.theme),
          icon: Icon(Icons.color_lens_outlined),
          selectedOption: selectedTheme,
          options: options,
          displayOptions: options,
          onChanged: (value) {
            if (value != null) context.read<ThemeCubit>().toggleTheme(value);
          },
        );
      },
    );
  }

  Widget _buildLanguageTile(BuildContext context) {
    return BlocBuilder<LocaleCubit, Locale>(
      builder: (context, locale) {
        final selectedLanguage = locale.languageCode;
        return _buildOptionTile(
          title: context.tr(I18nKeys.language),
          icon: Icon(Icons.language),
          selectedOption: selectedLanguage,
          options: supportedLocaleCode,
          displayOptions: [context.tr(I18nKeys.english), context.tr(I18nKeys.vietnamese)],
          onChanged: (value) {
            if (value != null) context.read<LocaleCubit>().setLocale(Locale(value));
          },
        );
      },
    );
  }

  Widget _buildOptionTile({
    required String title,
    required Icon icon,
    required String selectedOption,
    required List<String> options,
    required List<String> displayOptions,
    required ValueChanged<String?>? onChanged,
  }) {
    return ListTile(
      title: Text(title),
      leading: icon,
      subtitle: Text(_getDisplayValue(selectedOption, options, displayOptions) ?? ''),
      trailing: const Icon(Icons.arrow_drop_down),
      onTap: () {
        _showDropdownDialog(title, selectedOption, options, displayOptions, onChanged);
      },
    );
  }

  String? _getDisplayValue(String value, List<String> values, List<String> displayValues) {
    int index = values.indexOf(value);
    if (index == -1 || index >= displayValues.length) return null;
    return displayValues[index];
  }

  void _showDropdownDialog(
    String title,
    String? currentValue,
    List<String> values,
    List<String> displayValues,
    ValueChanged<String?>? onChanged,
  ) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text('Select $title'),
          content: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: List<Widget>.generate(values.length, (index) {
                return ListTile(
                  title: Text(displayValues[index]),
                  onTap: () {
                    if (onChanged != null) {
                      onChanged(values[index]);
                      context.pop();
                    }
                  },
                  trailing: currentValue == values[index] ? Icon(Icons.check) : null,
                );
              }),
            ),
          ),
        );
      },
    );
  }
}


Path: lib\features\user\data\datasources\user_remote_data_source.dart
Code:
import 'package:dio/dio.dart';

import '../../../../core/constants/api_endpoints.dart';
import '../../../../core/constants/enum.dart';
import '../../../../core/errors/exceptions.dart';
import '../../../auth/domain/usecases/update_password_usecase.dart';
import '../../domain/usecases/bookmark_post_usecase.dart';
import '../../domain/usecases/get_all_users_usecase.dart';
import '../../domain/usecases/update_friend_list_usecase.dart';
import '../models/user_detail_model.dart';
import '../models/user_model.dart';

abstract class UserRemoteDataSource {
  Future<List<UserModel>> getAllUsers(GetAllUsersWithExcludeParams params);
  Future<UserModel> getUserById(String id);
  Future<UserDetailModel> getUserDetail(String id);
  Future<UserModel> updateUser(UserModel user);
  Future<void> updateFriendList(UpdateFriendListParams params);
  Future<void> bookmarkPost(BookmarkPostParams params);
  Future<void> updateUserPassword(UpdateUserPasswordParams params);
}

class UserRemoteDataSourceImpl implements UserRemoteDataSource {
  final Dio dio;

  UserRemoteDataSourceImpl({required this.dio});

  @override
  Future<List<UserModel>> getAllUsers(GetAllUsersWithExcludeParams params) async {
    try {
      final response = await dio.get(
        ApiEndpoints.users,
        queryParameters: {
          '_page': params.page,
          '_limit': params.limit,
          '_order': params.order.getString(),
          'exclude': params.excludeId,
        },
      );
      final data = response.data as List;
      return data.map((json) => UserModel.fromJson(json)).toList();
    } on DioException catch (e, s) {
      handleDioException(e, s, 'getAllUsers(GetAllUsersWithExcludeParams params)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }

  @override
  Future<UserModel> getUserById(String id) async {
    try {
      final response = await dio.get(ApiEndpoints.singleUser(id));
      return UserModel.fromJson(response.data);
    } on DioException catch (e, s) {
      handleDioException(e, s, 'getUserById(String id)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }

  @override
  Future<UserDetailModel> getUserDetail(String id) async {
    try {
      final response = await dio.get(ApiEndpoints.userDetail(id));
      return UserDetailModel.fromJson(response.data);
    } on DioException catch (e, s) {
      handleDioException(e, s, 'getUserDetail(String id)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }

  @override
  Future<UserModel> updateUser(UserModel user) async {
    try {
      final response = await dio.put(ApiEndpoints.singleUser(user.id), data: user.toJson());
      return UserModel.fromJson(response.data);
    } on DioException catch (e, s) {
      handleDioException(e, s, 'updateUser(UserModel user)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }

  @override
  Future<void> updateUserPassword(UpdateUserPasswordParams params) async {
    try {
      await dio.patch(
        ApiEndpoints.singleUser(params.userId),
        data: {'password': params.newPassword},
      );
      return;
    } on DioException catch (e, s) {
      handleDioException(e, s, 'updateUserPassword(UpdateUserPasswordParam user)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }

  @override
  Future<void> updateFriendList(UpdateFriendListParams params) async {
    try {
      await dio.patch(
        ApiEndpoints.userFriendList(params.userId),
        data: {'friendIds': params.friendIds},
      );
      return;
    } on DioException catch (e, s) {
      handleDioException(e, s, 'updateFriendList(String userId, List<int> friendIds)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }

  @override
  Future<void> bookmarkPost(BookmarkPostParams params) async {
    try {
      await dio.patch(
        ApiEndpoints.bookmarkPost(userId: params.userId),
        data: {'postId': params.postId},
      );
      return;
    } on DioException catch (e, s) {
      handleDioException(e, s, 'updateFriendList(String userId, List<int> friendIds)');
    } catch (e, s) {
      throw ServerException(message: e.toString(), stackTrace: s);
    }
  }
}


Path: lib\features\user\data\models\user_detail_model.dart
Code:
import '../../../../core/constants/api_mapping.dart';
import '../../../../core/utils/num_utils.dart';
import '../../domain/entities/user_detail_entity.dart';

class UserDetailModel extends UserDetailEntity {
  const UserDetailModel({required super.friends, required super.posts, required super.comments});

  factory UserDetailModel.fromJson(Map<String, dynamic> json) {
    return UserDetailModel(
      friends: intParse(value: json[UserDetailApiMap.kFriends].toString()),
      posts: intParse(value: json[UserDetailApiMap.kPosts].toString()),
      comments: intParse(value: json[UserDetailApiMap.kComments].toString()),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      UserDetailApiMap.kFriends: friends,
      UserDetailApiMap.kPosts: posts,
      UserDetailApiMap.kComments: comments,
    };
  }

  factory UserDetailModel.fromEntity(UserDetailEntity userDetail) {
    return UserDetailModel(
      friends: userDetail.friends,
      posts: userDetail.posts,
      comments: userDetail.comments,
    );
  }
}


Path: lib\features\user\data\models\user_model.dart
Code:
import '../../../../core/constants/api_mapping.dart';
import '../../domain/entities/user_entity.dart';

class UserModel extends UserEntity {
  const UserModel({
    required super.id,
    required super.fullName,
    required super.userName,
    required super.email,
    required super.avatar,
    required super.bookmarksId,
    required super.friendsId,
    required super.cover,
    required super.about,
    required super.createdAt,
    required super.updatedAt,
  });

  factory UserModel.fromJson(Map<String, dynamic> json) {
    return UserModel(
      id: json[UserApiMap.kId] as String,
      fullName: json[UserApiMap.kFullName] as String,
      userName: json[UserApiMap.kUserName] as String,
      email: json[UserApiMap.kEmail] as String,
      avatar: json[UserApiMap.kAvatar] as String,
      cover: json[UserApiMap.kCover] as String,
      about: json[UserApiMap.kAbout] as String,
      bookmarksId:
          (json[UserApiMap.kBookmarksId] as List<dynamic>).map((e) => e.toString()).toList(),
      friendsId: (json[UserApiMap.kFriendIds] as List<dynamic>).map((e) => e.toString()).toList(),
      createdAt: DateTime.parse(json[kCreatedAt] as String),
      updatedAt: DateTime.parse(json[kUpdatedAt] as String),
    );
  }

  factory UserModel.fromEntity(UserEntity user) {
    return UserModel(
      id: user.id,
      fullName: user.fullName,
      userName: user.userName,
      email: user.email,
      avatar: user.avatar,
      cover: user.cover,
      bookmarksId: user.bookmarksId,
      friendsId: user.friendsId,
      about: user.about,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      UserApiMap.kId: id,
      UserApiMap.kFullName: fullName,
      UserApiMap.kUserName: userName,
      UserApiMap.kEmail: email,
      UserApiMap.kAvatar: avatar,
      UserApiMap.kCover: cover,
      UserApiMap.kBookmarksId: bookmarksId,
      UserApiMap.kFriendIds: friendsId,
      UserApiMap.kAbout: about,
      kCreatedAt: createdAt.toIso8601String(),
      kUpdatedAt: updatedAt.toIso8601String(),
    };
  }

  @override
  UserModel copyWith({
    String? id,
    String? fullName,
    String? userName,
    String? email,
    String? avatar,
    String? cover,
    String? about,
    List<String>? bookmarksId,
    List<String>? friendsId,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return UserModel(
      id: id ?? this.id,
      fullName: fullName ?? this.fullName,
      userName: userName ?? this.userName,
      email: email ?? this.email,
      avatar: avatar ?? this.avatar,
      cover: cover ?? this.cover,
      about: about ?? this.about,
      bookmarksId: bookmarksId ?? this.bookmarksId,
      friendsId: friendsId ?? this.friendsId,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}


Path: lib\features\user\data\repositories\user_repository_impl.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/exceptions.dart';
import '../../../../core/errors/failures.dart';
import '../../../../core/network/network_info.dart';
import '../../../../core/usecase/usecase.dart';
import '../../domain/entities/user_detail_entity.dart';
import '../../domain/entities/user_entity.dart';
import '../../domain/repositories/user_repository.dart';
import '../../domain/usecases/bookmark_post_usecase.dart';
import '../../domain/usecases/get_all_users_usecase.dart';
import '../../domain/usecases/update_friend_list_usecase.dart';
import '../datasources/user_remote_data_source.dart';
import '../models/user_model.dart';

class UserRepositoryImpl implements UserRepository {
  final UserRemoteDataSource remoteDataSource;
  final NetworkInfo networkInfo;

  UserRepositoryImpl({required this.remoteDataSource, required this.networkInfo});

  @override
  Future<Either<Failure, List<UserEntity>>> getAllUsers(GetAllUsersWithExcludeParams params) async {
    if (await networkInfo.isConnected) {
      try {
        final users = await remoteDataSource.getAllUsers(params);
        return Right(users);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    } else {
      return Left(NoInternetFailure());
    }
  }

  @override
  Future<Either<Failure, UserEntity>> getUserById(IdParams params) async {
    if (await networkInfo.isConnected) {
      try {
        final user = await remoteDataSource.getUserById(params.id);
        return Right(user);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    } else {
      return Left(NoInternetFailure());
    }
  }

  @override
  Future<Either<Failure, UserEntity>> updateUser(UserEntity user) async {
    if (await networkInfo.isConnected) {
      try {
        final updatedUser = await remoteDataSource.updateUser(UserModel.fromEntity(user));
        return Right(updatedUser);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    } else {
      return Left(NoInternetFailure());
    }
  }

  @override
  Future<Either<Failure, void>> updateFriendList(UpdateFriendListParams params) async {
    if (await networkInfo.isConnected) {
      try {
        await remoteDataSource.updateFriendList(params);

        return const Right(unit);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    } else {
      return Left(NoInternetFailure());
    }
  }

  @override
  Future<Either<Failure, void>> bookmarkPost(BookmarkPostParams params) async {
    if (await networkInfo.isConnected) {
      try {
        await remoteDataSource.bookmarkPost(params);
        return const Right(unit);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    } else {
      return Left(NoInternetFailure());
    }
  }

  @override
  Future<Either<Failure, UserDetailEntity>> getUserDetail(IdParams params) async {
    if (await networkInfo.isConnected) {
      try {
        final user = await remoteDataSource.getUserDetail(params.id);
        return Right(user);
      } catch (e) {
        return Left(handleRepositoryException(e));
      }
    } else {
      return Left(NoInternetFailure());
    }
  }
}


Path: lib\features\user\domain\entities\user_detail_entity.dart
Code:
import 'package:equatable/equatable.dart';

class UserDetailEntity extends Equatable {
  final int friends;
  final int posts;
  final int comments;

  const UserDetailEntity({required this.friends, required this.posts, required this.comments});

  @override
  List<Object?> get props => [friends, posts, comments];
}


Path: lib\features\user\domain\entities\user_entity.dart
Code:
import 'package:equatable/equatable.dart';

class UserEntity extends Equatable {
  final String id;
  final String fullName;
  final String userName;
  final String email;
  final String avatar;
  final String cover;
  final String about;
  final List<String> bookmarksId;
  final List<String> friendsId;
  final DateTime createdAt;
  final DateTime updatedAt;

  const UserEntity({
    required this.id,
    required this.fullName,
    required this.userName,
    required this.email,
    required this.avatar,
    required this.bookmarksId,
    required this.friendsId,
    required this.cover,
    required this.about,
    required this.createdAt,
    required this.updatedAt,
  });

  @override
  List<Object?> get props => [
    id,
    fullName,
    userName,
    email,
    avatar,
    bookmarksId,
    friendsId,
    cover,
    about,
  ];

  UserEntity copyWith({
    String? id,
    String? fullName,
    String? userName,
    String? email,
    String? avatar,
    String? cover,
    String? about,
    List<String>? bookmarksId,
    List<String>? friendsId,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return UserEntity(
      id: id ?? this.id,
      fullName: fullName ?? this.fullName,
      userName: userName ?? this.userName,
      email: email ?? this.email,
      avatar: avatar ?? this.avatar,
      cover: avatar ?? this.cover,
      bookmarksId: bookmarksId ?? this.bookmarksId,
      friendsId: friendsId ?? this.friendsId,
      about: about ?? this.about,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}


Path: lib\features\user\domain\repositories\user_repository.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/user_detail_entity.dart';
import '../entities/user_entity.dart';
import '../usecases/bookmark_post_usecase.dart';
import '../usecases/get_all_users_usecase.dart';
import '../usecases/update_friend_list_usecase.dart';

abstract class UserRepository {
  Future<Either<Failure, List<UserEntity>>> getAllUsers(GetAllUsersWithExcludeParams params);
  Future<Either<Failure, UserEntity>> getUserById(IdParams params);
  Future<Either<Failure, UserDetailEntity>> getUserDetail(IdParams params);
  Future<Either<Failure, UserEntity>> updateUser(UserEntity userEntity);
  Future<Either<Failure, void>> updateFriendList(UpdateFriendListParams params);
  Future<Either<Failure, void>> bookmarkPost(BookmarkPostParams params);
}


Path: lib\features\user\domain\usecases\bookmark_post_usecase.dart
Code:
import 'package:dartz/dartz.dart';
import 'package:equatable/equatable.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../repositories/user_repository.dart';

class BookmarkPostUseCase implements UseCase<void, BookmarkPostParams> {
  final UserRepository repository;

  BookmarkPostUseCase(this.repository);

  @override
  Future<Either<Failure, void>> call(BookmarkPostParams params) async {
    return await repository.bookmarkPost(params);
  }
}

class BookmarkPostParams extends Equatable {
  final List<String> bookmarkedPostIds;
  final String postId;
  final String userId;

  const BookmarkPostParams({
    required this.postId,
    required this.bookmarkedPostIds,
    required this.userId,
  });

  @override
  List<Object?> get props => [postId, bookmarkedPostIds, userId];
}


Path: lib\features\user\domain\usecases\get_all_users_usecase.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/user_entity.dart';
import '../repositories/user_repository.dart';

class GetAllUsersUseCase implements UseCase<List<UserEntity>, GetAllUsersWithExcludeParams> {
  final UserRepository repository;

  GetAllUsersUseCase(this.repository);

  @override
  Future<Either<Failure, List<UserEntity>>> call(GetAllUsersWithExcludeParams params) async {
    return await repository.getAllUsers(params);
  }
}

class GetAllUsersWithExcludeParams extends PaginationParams {
  final String excludeId;
  const GetAllUsersWithExcludeParams({
    required this.excludeId,
    required super.page,
    required super.limit,
    super.order,
  });
}


Path: lib\features\user\domain\usecases\get_user_by_id_usecase.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/user_entity.dart';
import '../repositories/user_repository.dart';

class GetUserByIdUseCase implements UseCase<UserEntity, IdParams> {
  final UserRepository repository;

  GetUserByIdUseCase(this.repository);

  @override
  Future<Either<Failure, UserEntity>> call(IdParams params) async {
    return await repository.getUserById(params);
  }
}


Path: lib\features\user\domain\usecases\get_user_detail_usecase.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/user_detail_entity.dart';
import '../repositories/user_repository.dart';

class GetUserDetailUseCase implements UseCase<UserDetailEntity, IdParams> {
  final UserRepository repository;

  GetUserDetailUseCase(this.repository);

  @override
  Future<Either<Failure, UserDetailEntity>> call(IdParams params) async {
    return await repository.getUserDetail(params);
  }
}


Path: lib\features\user\domain\usecases\update_friend_list_usecase.dart
Code:
import 'package:dartz/dartz.dart';
import 'package:equatable/equatable.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../repositories/user_repository.dart';

class UpdateFriendListUseCase implements UseCase<void, UpdateFriendListParams> {
  final UserRepository repository;

  UpdateFriendListUseCase(this.repository);

  @override
  Future<Either<Failure, void>> call(UpdateFriendListParams params) async {
    return await repository.updateFriendList(params);
  }
}

class UpdateFriendListParams extends Equatable {
  final String userId;
  final List<String> friendIds;

  const UpdateFriendListParams({required this.userId, required this.friendIds});

  @override
  List<Object?> get props => [userId, friendIds];
}


Path: lib\features\user\domain\usecases\update_user_usecase.dart
Code:
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../entities/user_entity.dart';
import '../repositories/user_repository.dart';

class UpdateUserUseCase implements UseCase<UserEntity, UserEntity> {
  final UserRepository repository;

  UpdateUserUseCase(this.repository);

  @override
  Future<Either<Failure, UserEntity>> call(UserEntity userEntity) async {
    return await repository.updateUser(userEntity);
  }
}


Path: lib\features\user\presentation\blocs\user_bloc.dart
Code:
import 'package:equatable/equatable.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../app/logs.dart';
import '../../../../core/constants/pagination.dart';
import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/usecase.dart';
import '../../domain/entities/user_entity.dart';
import '../../domain/usecases/bookmark_post_usecase.dart';
import '../../domain/usecases/get_all_users_usecase.dart';
import '../../domain/usecases/get_user_by_id_usecase.dart';
import '../../domain/usecases/update_friend_list_usecase.dart';
import '../../domain/usecases/update_user_usecase.dart';

part 'user_event.dart';
part 'user_state.dart';

class UserBloc extends Bloc<UserEvent, UserState> {
  final GetAllUsersUseCase getAllUsersUseCase;
  final GetUserByIdUseCase getUserByIdUseCase;
  final UpdateUserUseCase updateUserUseCase;
  final UpdateFriendListUseCase updateFriendListUseCase;
  final BookmarkPostUseCase bookmarkPostUseCase;
  final LogService logService;

  UserBloc({
    required this.getAllUsersUseCase,
    required this.getUserByIdUseCase,
    required this.updateUserUseCase,
    required this.updateFriendListUseCase,
    required this.bookmarkPostUseCase,
    required this.logService,
  }) : super(UserInitial()) {
    on<GetAllUsersEvent>(_onGetAllUsers);
    on<GetUserByIdEvent>(_onGetUserById);
    on<UpdateUserEvent>(_onUpdateUser);
    on<UpdateFriendListEvent>(_onUpdateFriendList);
    on<BookmarkPostEvent>(_onBookmarkPostUsers);
  }

  final _allUsersPS = PaginationStorage();

  Future<void> _onGetAllUsers(GetAllUsersEvent event, Emitter<UserState> emit) async {
    final results = await getAllUsersUseCase(
      GetAllUsersWithExcludeParams(
        excludeId: event.exclude,
        page: _allUsersPS.currentPage,
        limit: _allUsersPS.limit,
      ),
    );

    results.fold(
      (failure) {
        logService.w(
          '$failure occur at _onGetAllUsers(GetAllUsersEvent event, Emitter<UserState> emit)',
        );
        emit(UserError(failure: failure));
      },
      (users) {
        if (users.isEmpty) {
          _allUsersPS.hasMore = false;
          if (state is UsersLoaded) {
            emit((state as UsersLoaded).copyWith(hasMore: false));
            return;
          } else {
            emit(UsersLoaded(users: [], hasMore: false));
            return;
          }
        }
        if (_allUsersPS.currentPage == 1 && users.length < _allUsersPS.limit) {
          _allUsersPS.hasMore = false;
        }
        _allUsersPS.currentPage++;

        if (state is UsersLoaded) {
          emit((state as UsersLoaded).copyWith(users: users));
          return;
        } else {
          emit(UsersLoaded(users: users, hasMore: _allUsersPS.hasMore));
          return;
        }
      },
    );
  }

  Future<void> _onGetUserById(GetUserByIdEvent event, Emitter<UserState> emit) async {
    emit(UserLoading());
    final result = await getUserByIdUseCase(IdParams(id: event.id));
    emit(
      result.fold((failure) {
        logService.w(
          '$failure occur at _onGetUserById(GetUserByIdEvent event, Emitter<UserState> emit)',
        );
        return UserError(failure: failure);
      }, (user) => UserLoaded(user: user)),
    );
  }

  Future<void> _onUpdateUser(UpdateUserEvent event, Emitter<UserState> emit) async {
    emit(UserLoading());
    final result = await updateUserUseCase(event.user);
    emit(
      result.fold((failure) {
        logService.w(
          '$failure occur at _onUpdateUser(UpdateUserEvent event, Emitter<UserState> emit)',
        );
        return UserError(failure: failure);
      }, (user) => UserLoaded(user: user)),
    );
  }

  Future<void> _onUpdateFriendList(UpdateFriendListEvent event, Emitter<UserState> emit) async {
    final result = await updateFriendListUseCase(
      UpdateFriendListParams(userId: event.userId, friendIds: event.friendIds),
    );
    result.fold(
      (failure) {
        logService.w(
          '$failure occur at _onUpdateFriendList(UpdateFriendListEvent event, Emitter<UserState> emit)',
        );
        emit(UserError(failure: failure));
      },
      (_) => {
        if (state is UserLoaded)
          {emit(UserLoaded(user: (state as UserLoaded).user.copyWith(friendsId: event.friendIds)))},
      },
    );
  }

  Future<void> _onBookmarkPostUsers(BookmarkPostEvent event, Emitter<UserState> emit) async {
    final result = await bookmarkPostUseCase(
      BookmarkPostParams(
        postId: event.postId,
        bookmarkedPostIds: event.bookmarkedPostIds,
        userId: event.userId,
      ),
    );

    await result.fold(
      (failure) {
        logService.w(
          '$failure occur at _onBookmarkPostUsers(BookmarkPostEvent event, Emitter<UserState> emit)',
        );
        emit(UserError(failure: failure));
      },
      (_) async {
        await _bookmarkPost(event.userId, emit);
      },
    );
  }

  Future<void> _bookmarkPost(String userId, Emitter<UserState> emit) async {
    final result = await getUserByIdUseCase(IdParams(id: userId));
    emit(
      result.fold((failure) {
        logService.w('$failure occur at _getUserById(String userId, Emitter<UserState> emit)');
        return UserError(failure: failure);
      }, (user) => UserLoaded(user: user)),
    );
  }
}


Path: lib\features\user\presentation\blocs\user_detail_bloc.dart
Code:
import 'package:equatable/equatable.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../app/logs.dart';
import '../../../../core/errors/failures.dart';
import '../../../../core/usecase/params.dart';
import '../../domain/entities/user_detail_entity.dart';
import '../../domain/usecases/get_user_detail_usecase.dart';

part 'user_detail_event.dart';
part 'user_detail_state.dart';

class UserDetailBloc extends Bloc<UserDetailEvent, UserDetailState> {
  final GetUserDetailUseCase getUserDetailUseCase;
  final LogService logService;

  UserDetailBloc({required this.getUserDetailUseCase, required this.logService})
    : super(UserDetailInitial()) {
    on<GetUserDetailEvent>(_onGetUserDetail);
  }

  Future<void> _onGetUserDetail(GetUserDetailEvent event, Emitter<UserDetailState> emit) async {
    final result = await getUserDetailUseCase(IdParams(id: event.userId));
    emit(
      result.fold((failure) {
        logService.w(
          '$failure occur at _onGetUserById(GetUserByIdEvent event, Emitter<UserState> emit)',
        );
        return UserDetailError(failure: failure);
      }, (userDetail) => UserDetailLoaded(userDetail: userDetail)),
    );
  }
}


Path: lib\features\user\presentation\blocs\user_detail_event.dart
Code:
part of 'user_detail_bloc.dart';

abstract class UserDetailEvent extends Equatable {
  const UserDetailEvent();

  @override
  List<Object> get props => [];
}

class GetUserDetailEvent extends UserDetailEvent {
  final String userId;

  const GetUserDetailEvent({required this.userId});
}


Path: lib\features\user\presentation\blocs\user_detail_state.dart
Code:
part of 'user_detail_bloc.dart';

abstract class UserDetailState extends Equatable {
  const UserDetailState();

  @override
  List<Object> get props => [];
}

class UserDetailInitial extends UserDetailState {
  const UserDetailInitial();
}

class UserDetailLoaded extends UserDetailState {
  final UserDetailEntity userDetail;

  const UserDetailLoaded({required this.userDetail});

  @override
  List<Object> get props => [userDetail];
}

class UserDetailError extends UserDetailState {
  final Failure failure;

  const UserDetailError({required this.failure});

  @override
  List<Object> get props => [failure];
}


Path: lib\features\user\presentation\blocs\user_event.dart
Code:
part of 'user_bloc.dart';

abstract class UserEvent extends Equatable {
  const UserEvent();

  @override
  List<Object> get props => [];
}

class GetAllUsersEvent extends UserEvent {
  final String exclude;

  const GetAllUsersEvent({required this.exclude});
}

class GetUserByIdEvent extends UserEvent {
  final String id;

  const GetUserByIdEvent({required this.id});

  @override
  List<Object> get props => [id];
}

class UpdateUserEvent extends UserEvent {
  final UserEntity user;

  const UpdateUserEvent({required this.user});
  @override
  List<Object> get props => [user];
}

class UpdateFriendListEvent extends UserEvent {
  final String userId;
  final List<String> friendIds;
  const UpdateFriendListEvent({required this.userId, required this.friendIds});
  @override
  List<Object> get props => [userId, friendIds];
}

class BookmarkPostEvent extends UserEvent {
  final String userId;
  final String postId;
  final List<String> bookmarkedPostIds;

  const BookmarkPostEvent({
    required this.userId,
    required this.postId,
    required this.bookmarkedPostIds,
  });

  @override
  List<Object> get props => [userId, postId, bookmarkedPostIds];
}


Path: lib\features\user\presentation\blocs\user_state.dart
Code:
part of 'user_bloc.dart';

abstract class UserState extends Equatable {
  const UserState();

  @override
  List<Object> get props => [];
}

class UserInitial extends UserState {}

class UserLoading extends UserState {}

class UsersLoaded extends UserState {
  final List<UserEntity> users;
  final bool hasMore;

  const UsersLoaded({required this.users, required this.hasMore});

  UsersLoaded copyWith({List<UserEntity>? users, bool? hasMore}) {
    return UsersLoaded(
      users: users != null ? [...this.users, ...users] : this.users,
      hasMore: hasMore ?? this.hasMore,
    );
  }

  @override
  List<Object> get props => [users, hasMore];
}

class UserLoaded extends UserState {
  final UserEntity user;

  const UserLoaded({required this.user});

  @override
  List<Object> get props => [user];
}

class UserError extends UserState {
  final Failure failure;

  const UserError({required this.failure});

  @override
  List<Object> get props => [failure];
}

class FriendListUpdated extends UserState {}

class BookmarkPostFinish extends UserState {
  final UserEntity user;

  const BookmarkPostFinish({required this.user});

  @override
  List<Object> get props => [user];
}


Path: lib\features\user\presentation\pages\users_page.dart
Code:
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';

import '../../../../app/locale.dart';
import '../../../../app/routes.dart';
import '../../../../core/extensions/build_content_extensions.dart';
import '../../../../core/extensions/num_extension.dart';
import '../../../../core/extensions/scroll_controller.dart';
import '../../../../core/extensions/widget_extensions.dart';
import '../../../../core/widgets/has_more_incaditor.dart';
import '../../../../core/widgets/layout.dart';
import '../../../../injection_container.dart';
import '../../../auth/presentation/blocs/auth_bloc.dart';
import '../blocs/user_bloc.dart';
import '../widgets/user_profile.dart';

class UsersPage extends StatefulWidget {
  const UsersPage({super.key});

  @override
  State<UsersPage> createState() => _UsersPageState();
}

class _UsersPageState extends State<UsersPage> {
  final ScrollController _scrollController = ScrollController();
  late UserBloc _userInfoBloc;
  late UserBloc _userListBloc;
  bool _isUpdatingFriendList = false;
  bool _isLoadingUserList = false;

  @override
  void initState() {
    super.initState();
    _userInfoBloc =
        sl<UserBloc>()..add(GetUserByIdEvent(id: (sl<AuthBloc>().state as AuthLoaded).auth.id));
    _userListBloc = sl<UserBloc>();
    _scrollController.addListener(_onScroll);
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _userInfoBloc.close();
    _userListBloc.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text(context.tr(I18nKeys.users)), centerTitle: true),
      body: safeWrapContainer(
        context,
        _scrollController,
        border: Border.all(color: context.colorScheme.outline),
        BlocProvider(
          create: (context) => _userInfoBloc,
          child: BlocBuilder<UserBloc, UserState>(
            builder: (_, userInfoState) {
              if (userInfoState is UserLoading) {
                return const Center(child: CircularProgressIndicator());
              } else if (userInfoState is UserError) {
                return Center(child: Text('Error: ${userInfoState.failure.message}'));
              } else if (userInfoState is UserLoaded) {
                _loadUserList();

                return Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    UserProfile(user: userInfoState.user),
                    24.sbH(),

                    BlocProvider(
                      create: (context) => _userListBloc,
                      child: BlocBuilder<UserBloc, UserState>(
                        builder: (_, userListState) {
                          if (userListState is UserInitial) {
                            return const Center(child: CircularProgressIndicator());
                          } else if (userListState is UserError) {
                            return Center(child: Text('Error: ${userListState.failure.message}'));
                          } else if (userListState is UsersLoaded) {
                            _isUpdatingFriendList = false;
                            _isLoadingUserList = false;

                            final hasMore = userListState.hasMore;

                            return _buildListUsers(hasMore, userListState, userInfoState, context);
                          } else {
                            return Center(child: Text('Unknown User List State: $userListState'));
                          }
                        },
                      ),
                    ),
                  ],
                );
              } else {
                return Center(child: Text('Unknown User Info State: $userInfoState'));
              }
            },
          ),
        ),
      ),
    );
  }

  void _loadUserList() {
    if (_isLoadingUserList) return;
    _isLoadingUserList = true;

    if (_userInfoBloc.state is UserLoaded) {
      _userListBloc.add(GetAllUsersEvent(exclude: (_userInfoBloc.state as UserLoaded).user.id));
    }
  }

  void _onScroll() {
    if (_scrollController.isBottom && _userInfoBloc.state is UserLoaded) {
      _loadUserList();
    }
  }

  void _onAddFriend(String userId) {
    if (_isUpdatingFriendList) return;

    _isUpdatingFriendList = true;

    if (_userInfoBloc.state is UserLoaded) {
      final user = (_userInfoBloc.state as UserLoaded).user;
      final friendListId = List<String>.from(user.friendsId);
      if (friendListId.contains(userId)) {
        friendListId.remove(userId);
      } else {
        friendListId.add(userId);
      }
      _userInfoBloc.add(UpdateFriendListEvent(userId: user.id, friendIds: friendListId));
    }
  }

  ListView _buildListUsers(
    bool hasMore,
    UsersLoaded userListState,
    UserLoaded userInfoState,
    BuildContext context,
  ) {
    return ListView.separated(
      itemCount: userListState.users.length + 1,
      physics: NeverScrollableScrollPhysics(),
      shrinkWrap: true,
      itemBuilder: (_, index) {
        if (index == userListState.users.length) {
          return hasMoreWidget(context, hasMore);
        }

        final user = userListState.users[index];
        final isFriend = userInfoState.user.friendsId.contains(user.id);
        return ListTile(
          leading: CircleAvatar(backgroundImage: CachedNetworkImageProvider(user.avatar)),
          title: Text(user.fullName),
          subtitle: Text(user.email),
          onTap: () {
            context.push('${Paths.userProfile}/${user.id}');
          },
          trailing:
              isFriend
                  ? FilledButton(
                    onPressed: () => _onAddFriend(user.id),
                    child: Text(context.tr(I18nKeys.removeFriends)),
                  )
                  : ElevatedButton(
                    onPressed: () => _onAddFriend(user.id),
                    child: Text(context.tr(I18nKeys.addFriends)),
                  ),
        );
      },
      separatorBuilder: (_, _) => Padding(padding: 4.eiHori, child: Divider()),
    );
  }
}


Path: lib\features\user\presentation\pages\user_profile_page.dart
Code:
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../app/locale.dart';
import '../../../../core/extensions/num_extension.dart';
import '../../../../core/extensions/scroll_controller.dart';
import '../../../../core/extensions/widget_extensions.dart';
import '../../../../core/widgets/layout.dart';
import '../../../../injection_container.dart';
import '../../../auth/presentation/blocs/auth_bloc.dart';
import '../../../post/domain/entities/post_entity.dart';
import '../../../post/domain/usecases/create_post_usecase.dart';
import '../../../post/presentation/blocs/post_bloc.dart';
import '../../../post/presentation/widgets/list_post.dart';
import '../../domain/entities/user_detail_entity.dart';
import '../../domain/entities/user_entity.dart';
import '../blocs/user_bloc.dart';
import '../blocs/user_detail_bloc.dart';
import '../widgets/user_profile.dart';

class UserProfilePage extends StatefulWidget {
  final String userId;
  const UserProfilePage({super.key, required this.userId});

  @override
  State<UserProfilePage> createState() => _UserProfilePageState();
}

class _UserProfilePageState extends State<UserProfilePage> {
  final _fullname = TextEditingController();
  final _aboutMe = TextEditingController();
  final _email = TextEditingController();

  late UserBloc _userBloc;
  late UserDetailBloc _userDetailBloc;
  late PostBloc _postBloc;
  final ScrollController _scrollController = ScrollController();

  final _title = TextEditingController();
  final _body = TextEditingController();

  bool _isLoading = false;
  bool _hasMorePost = true;
  String _postsNum = '0';
  String _commentsNum = '0';
  String _friendsNum = '0';

  @override
  void initState() {
    super.initState();
    _userBloc = sl<UserBloc>()..add(GetUserByIdEvent(id: widget.userId));
    _userDetailBloc = sl<UserDetailBloc>();
    _postBloc = sl<PostBloc>();
    _scrollController.addListener(_onScroll);
  }

  @override
  void dispose() {
    _fullname.dispose();
    _email.dispose();
    _aboutMe.dispose();

    _title.dispose();
    _body.dispose();

    _userBloc.close();
    _userDetailBloc.close();
    _postBloc.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar:
          _isMyProfile()
              ? AppBar(
                title: Text(context.tr(I18nKeys.myProfile)),
                centerTitle: true,
                actions: [IconButton(icon: Icon(Icons.edit), onPressed: _showUpdateUserDialog)],
              )
              : AppBar(title: Text(context.tr(I18nKeys.userProfile)), centerTitle: true),
      body: safeWrapContainer(
        context,
        _scrollController,
        MultiBlocProvider(
          providers: [
            BlocProvider<UserBloc>(create: (BuildContext context) => _userBloc),
            BlocProvider<PostBloc>(create: (BuildContext context) => _postBloc),
            BlocProvider<UserDetailBloc>(create: (BuildContext context) => _userDetailBloc),
          ],
          child: BlocBuilder<UserBloc, UserState>(
            bloc: _userBloc,
            builder: (_, userState) {
              if (userState is UserLoading || userState is UserInitial) {
                return const Center(child: CircularProgressIndicator());
              } else if (userState is UserError) {
                return Center(child: Text('Error: ${userState.failure.message}'));
              } else if (userState is UserLoaded) {
                final user = userState.user;
                _loadingDetailsAndPost(user.id);
                _updateUserInputController(user);

                return Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    _buildUserProfile(context, user),
                    BlocListener(
                      bloc: _userDetailBloc,
                      listener: (_, userDetailState) {
                        if (userDetailState is UserDetailLoaded) {
                          UserDetailEntity userDetail = userDetailState.userDetail;

                          setState(() {
                            _postsNum = userDetail.posts.toShortString;
                            _commentsNum = userDetail.comments.toShortString;
                            _friendsNum = userDetail.friends.toShortString;
                          });
                        }
                      },
                      child: Center(
                        child: SizedBox(
                          width: 350,
                          height: 100,
                          child: Column(
                            children: [
                              Expanded(
                                child: _buildStatusRow(
                                  context,
                                  posts: 'Posts',
                                  comments: 'Comments',
                                  friends: 'Friends',
                                  style: TextStyle(fontSize: 16),
                                ),
                              ),
                              Divider(height: 2),
                              Expanded(
                                child: _buildStatusRow(
                                  context,
                                  posts: _postsNum,
                                  comments: _commentsNum,
                                  friends: _friendsNum,
                                  style: TextStyle(fontSize: 18, fontWeight: FontWeight.w500),
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                    _buildUserDetail(user),
                    BlocBuilder<PostBloc, PostState>(
                      builder: (_, postState) {
                        if (postState is PostInitial) {
                          return Center(child: CircularProgressIndicator());
                        }
                        if (postState is PostError) {
                          return Center(child: Text('Error: ${postState.failure.message}'));
                        } else if (postState is PostsLoaded) {
                          _isLoading = false;
                          _hasMorePost = postState.hasMore;
                          return ListPostWidget(
                            postState.posts,
                            postState.hasMore,
                            isEditable: _isMyProfile(),
                            onDeletePostCallback: _showDeletePostDialog,
                            onEditPostCallback: _showPostDialog,
                          );
                        }
                        return Center(child: Text('Unknow Post State: $postState'));
                      },
                    ),
                  ],
                );
              }
              return Center(child: Text('Unknow User State: $userState'));
            },
          ),
        ),
      ),
      floatingActionButton:
          _isMyProfile()
              ? FloatingActionButton(
                onPressed: () => _showPostDialog(null),
                tooltip: 'Create Post',
                child: Icon(Icons.add),
              )
              : null,
    );
  }

  void _onScroll() {
    if (_isLoading) return;
    if (!_hasMorePost) return;

    if (_scrollController.isBottom &&
        _userBloc.state is UserLoaded &&
        _postBloc.state is PostsLoaded) {
      _isLoading = true;
      _postBloc.add(GetPostsByUserIdEvent(userId: (_userBloc.state as UserLoaded).user.id));
    }
  }

  void _showDeletePostDialog(PostEntity post) {
    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Delete Post'),
          content: SizedBox(
            width: 500,
            child: Text(
              'Are you sure you want to delete this post?\nPost: ${post.id} -- ${post.title}',
            ),
          ),
          actions: [
            TextButton(onPressed: () => Navigator.of(context).pop(), child: const Text('Cancel')),
            TextButton(
              onPressed: () {
                _postBloc.add(DeletePostEvent(post: post));
                Navigator.of(context).pop();
              },
              child: const Text('Delete Post'),
            ),
          ],
        );
      },
    );
  }

  void _showPostDialog(PostEntity? post) {
    bool isCreate = post == null;

    if (isCreate) {
      _title.text = '';
      _body.text = '';
    } else {
      _title.text = post.title;
      _body.text = post.body;
    }
    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(isCreate ? 'Create Post' : 'Update Post'),
          content: SizedBox(
            width: 500,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                TextFormField(
                  controller: _title,
                  maxLines: 1,
                  decoration: const InputDecoration(label: Text('Post Title')),
                ),
                16.sbH(),
                TextFormField(
                  controller: _body,
                  maxLines: 4,
                  decoration: const InputDecoration(label: Text('Post Body')),
                ),
              ],
            ),
          ),
          actions: [
            TextButton(onPressed: () => Navigator.of(context).pop(), child: const Text('Cancel')),
            TextButton(
              onPressed: () {
                if (_userBloc.state is UserLoaded) {
                  final userId = (_userBloc.state as UserLoaded).user.id;
                  if (isCreate) {
                    _postBloc.add(
                      CreatePostEvent(
                        params: CreatePostParams(
                          userId: userId,
                          title: _title.text,
                          body: _body.text,
                        ),
                      ),
                    );
                    _userDetailBloc.add(GetUserDetailEvent(userId: userId));
                    _loadingDetailsAndPost(userId);
                  } else {
                    PostEntity updatedPost = post.copyWith(body: _body.text, title: _title.text);
                    _postBloc.add(UpdatePostEvent(post: updatedPost));
                  }
                }
                Navigator.of(context).pop();
              },
              child: Text(isCreate ? 'Create Post' : 'Update Post'),
            ),
          ],
        );
      },
    );
  }

  bool _isMyProfile() {
    final userId = (sl<AuthBloc>().state as AuthLoaded).auth.id;
    if (userId == widget.userId) return true;
    return false;
  }

  void _loadingDetailsAndPost(String userId) {
    if (_isLoading) return;
    if (!_hasMorePost) return;
    _isLoading = true;
    _hasMorePost = false;

    _postBloc.add(GetPostsByUserIdEvent(userId: userId));
    _userDetailBloc.add(GetUserDetailEvent(userId: userId));
  }

  void _updateUserInputController(UserEntity user) {
    _aboutMe.text = user.about;
    _fullname.text = user.fullName;
    _email.text = user.email;
  }

  void _showUpdateUserDialog() {
    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Update User'),
          content: SizedBox(
            width: 500,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                TextFormField(
                  controller: _fullname,
                  decoration: const InputDecoration(
                    hintText: 'Update your Fullname',
                    label: Text('Fullname'),
                  ),
                ),
                16.sbH(),
                TextFormField(
                  controller: _email,
                  decoration: const InputDecoration(
                    hintText: 'Update your Email',
                    label: Text('Email'),
                  ),
                ),
                16.sbH(),
                TextFormField(
                  controller: _aboutMe,
                  decoration: const InputDecoration(
                    hintText: 'Update About Me',
                    label: Text('About Me'),
                  ),
                  maxLines: 4,
                ),
              ],
            ),
          ),
          actions: [
            TextButton(onPressed: () => Navigator.of(context).pop(), child: const Text('Cancel')),
            TextButton(
              onPressed: () {
                if (_userBloc.state is UserLoaded) {
                  final user = (_userBloc.state as UserLoaded).user;
                  final updatedUser = user.copyWith(
                    email: _email.text,
                    fullName: _fullname.text,
                    about: _aboutMe.text,
                  );
                  _userBloc.add(UpdateUserEvent(user: updatedUser));
                }
                Navigator.of(context).pop();
              },
              child: const Text('Update User'),
            ),
          ],
        );
      },
    );
  }

  Row _buildStatusRow(
    BuildContext context, {
    required String posts,
    required String comments,
    required String friends,
    required TextStyle style,
  }) {
    final dividerColor = Theme.of(context).dividerColor;
    return Row(
      children: [
        Expanded(child: Center(child: Text(posts, style: TextStyle(fontSize: 16)))),
        Container(width: 1, height: 50, color: dividerColor),
        Expanded(child: Center(child: Text(comments, style: TextStyle(fontSize: 16)))),
        Container(width: 1, height: 50, color: dividerColor),
        Expanded(child: Center(child: Text(friends, style: TextStyle(fontSize: 16)))),
      ],
    );
  }

  Padding _buildUserDetail(UserEntity user) {
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('About me', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 22)),
          SizedBox(height: 10),
          Text(user.about),
          SizedBox(height: 20),
          Row(
            children: [
              Icon(Icons.email),
              SizedBox(width: 10),
              Text('Email:', style: TextStyle(fontWeight: FontWeight.bold)),
              SizedBox(width: 20),
              Text(user.email),
            ],
          ),
          SizedBox(height: 20),
          Row(
            children: [
              Icon(Icons.calendar_month),
              SizedBox(width: 10),
              Text('Date Create:', style: TextStyle(fontWeight: FontWeight.bold)),
              SizedBox(width: 20),
              Text(user.createdAt.toIso8601String()),
            ],
          ),
          SizedBox(height: 20),
          Row(
            children: [
              Icon(Icons.update),
              SizedBox(width: 10),
              Text('Lastest update:', style: TextStyle(fontWeight: FontWeight.bold)),
              SizedBox(width: 20),
              Text(user.updatedAt.toIso8601String()),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildUserProfile(BuildContext context, UserEntity user) {
    return SizedBox(
      height: 400, // Adjust overall height as needed
      child: Stack(
        children: [
          // Cover image
          UserProfile(user: user, isDetail: true),

          Positioned(
            top: 330,
            left: 0,
            right: 0,
            child: Center(
              child: Text(
                user.fullName,
                style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
                textAlign: TextAlign.center,
              ),
            ),
          ),
        ],
      ),
    );
  }
}


Path: lib\features\user\presentation\widgets\user_profile.dart
Code:
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

import '../../../../app/locale.dart';
import '../../../../app/routes.dart';
import '../../../../core/extensions/build_content_extensions.dart';
import '../../../../core/extensions/num_extension.dart';
import '../../../../core/extensions/widget_extensions.dart';
import '../../../../core/widgets/widgets.dart';
import '../../domain/entities/user_entity.dart';

class UserProfile extends StatelessWidget {
  const UserProfile({super.key, required this.user, this.isDetail = false});
  final UserEntity user;
  final bool isDetail;

  @override
  Widget build(BuildContext context) {
    return InkWell(
      splashColor: Colors.transparent,
      focusColor: Colors.transparent,
      highlightColor: Colors.transparent,
      hoverColor: Colors.transparent,
      onTap: () => context.push('${Paths.userProfile}/${user.id}'),
      child: SizedBox(
        height: 350,

        child: Stack(
          children: [
            // Cover image
            SizedBox(height: 250, width: double.infinity, child: CachedImage(imageUrl: user.cover)),

            // User avatar
            Positioned(
              top: 135,
              left: 16,
              right: isDetail ? 16 : null,
              child: Container(
                decoration: BoxDecoration(
                  border: Border.all(color: context.colorScheme.surfaceBright, width: 10),
                  shape: BoxShape.circle,
                ),
                child: CircleAvatar(
                  radius: 90,
                  backgroundImage: CachedNetworkImageProvider(user.avatar),
                ),
              ),
            ),

            // User Detail
            if (!isDetail)
              Positioned(
                top: 260,
                left: 16 + 180 + 50,
                width: 1200 - 250,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      user.fullName,
                      style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
                      textAlign: TextAlign.center,
                    ),
                    8.sbH(),
                    FilledButton(
                      onPressed: () {
                        context.push('${Paths.userProfile}/${user.id}');
                      },
                      style: FilledButton.styleFrom(
                        shape: RoundedRectangleBorder(borderRadius: 6.radius),
                        padding:
                            context.isMobile
                                ? null
                                : EdgeInsets.symmetric(horizontal: 16, vertical: 20),
                      ),
                      child: Text(
                        context.tr(I18nKeys.viewProfile),
                        style: context.textTheme.labelLarge!.copyWith(
                          color: context.colorScheme.onPrimary,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
          ],
        ),
      ),
    );
  }
}


